{"id": "2507.22063", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2507.22063", "abs": "https://arxiv.org/abs/2507.22063", "authors": ["Wenjie Jacky Mo", "Qin Liu", "Xiaofei Wen", "Dongwon Jung", "Hadi Askari", "Wenxuan Zhou", "Zhe Zhao", "Muhao Chen"], "title": "RedCoder: Automated Multi-Turn Red Teaming for Code LLMs", "comment": null, "summary": "Large Language Models (LLMs) for code generation (i.e., Code LLMs) have\ndemonstrated impressive capabilities in AI-assisted software development and\ntesting. However, recent studies have shown that these models are prone to\ngenerating vulnerable or even malicious code under adversarial settings.\nExisting red-teaming approaches rely on extensive human effort, limiting their\nscalability and practicality, and generally overlook the interactive nature of\nreal-world AI-assisted programming, which often unfolds over multiple turns. To\nbridge these gaps, we present RedCoder, a red-teaming agent that engages victim\nmodels in multi-turn conversation to elicit vulnerable code. The pipeline to\nconstruct RedCoder begins with a multi-agent gaming process that simulates\nadversarial interactions, yielding a set of prototype conversations and an\narsenal of reusable attack strategies. We then fine-tune an LLM on these\nprototype conversations to serve as the backbone of RedCoder. Once deployed,\nRedCoder autonomously engages Code LLMs in multi-turn conversations,\ndynamically retrieving relevant strategies from the arsenal to steer the\ndialogue toward vulnerability-inducing outputs. Experiments across multiple\nCode LLMs show that our approach outperforms prior single-turn and multi-turn\nred-team methods in inducing vulnerabilities in code generation, offering a\nscalable and effective tool for evaluating the security boundaries of modern\ncode-generation systems."}
{"id": "2507.22064", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2507.22064", "abs": "https://arxiv.org/abs/2507.22064", "authors": ["Michael Cohoon", "Debbie Furman"], "title": "Machine Learning Experiences: A story of learning AI for use in enterprise software testing that can be used by anyone", "comment": null, "summary": "This paper details the machine learning (ML) journey of a group of people\nfocused on software testing. It tells the story of how this group progressed\nthrough a ML workflow (similar to the CRISP-DM process). This workflow consists\nof the following steps and can be used by anyone applying ML techniques to a\nproject: gather the data; clean the data; perform feature engineering on the\ndata; splitting the data into two sets, one for training and one for testing;\nchoosing a machine learning model; training the model; testing the model and\nevaluating the model performance. By following this workflow, anyone can\neffectively apply ML to any project that they are doing."}
{"id": "2507.22065", "categories": ["cs.SE", "cs.AI", "cs.CR", "cs.PL"], "pdf": "https://arxiv.org/pdf/2507.22065", "abs": "https://arxiv.org/abs/2507.22065", "authors": ["Xiaotao Feng", "Xiaogang Zhu", "Kun Hu", "Jincheng Wang", "Yingjie Cao", "Guang Gong", "Jianfeng Pan"], "title": "Fuzzing: Randomness? Reasoning! Efficient Directed Fuzzing via Large Language Models", "comment": null, "summary": "Fuzzing is highly effective in detecting bugs due to the key contribution of\nrandomness. However, randomness significantly reduces the efficiency of\nfuzzing, causing it to cost days or weeks to expose bugs. Even though directed\nfuzzing reduces randomness by guiding fuzzing towards target buggy locations,\nthe dilemma of randomness still challenges directed fuzzers. Two critical\ncomponents, which are seeds and mutators, contain randomness and are closely\ntied to the conditions required for triggering bugs. Therefore, to address the\nchallenge of randomness, we propose to use large language models (LLMs) to\nremove the randomness in seeds and reduce the randomness in mutators. With\ntheir strong reasoning and code generation capabilities, LLMs can be used to\ngenerate reachable seeds that target pre-determined locations and to construct\nbug-specific mutators tailored for specific bugs. We propose RandLuzz, which\nintegrates LLMs and directed fuzzing, to improve the quality of seeds and\nmutators, resulting in efficient bug exposure. RandLuzz analyzes function call\nchain or functionality to guide LLMs in generating reachable seeds. To\nconstruct bug-specific mutators, RandLuzz uses LLMs to perform bug analysis,\nobtaining information such as bug causes and mutation suggestions, which\nfurther help generate code that performs bug-specific mutations. We evaluate\nRandLuzz by comparing it with four state-of-the-art directed fuzzers, AFLGo,\nBeacon, WindRanger, and SelectFuzz. With RandLuzz-generated seeds, the fuzzers\nachieve an average speedup ranging from 2.1$\\times$ to 4.8$\\times$ compared to\nusing widely-used initial seeds. Additionally, when evaluated on individual\nbugs, RandLuzz achieves up to a 2.7$\\times$ speedup compared to the\nsecond-fastest exposure. On 8 bugs, RandLuzz can even expose them within 60\nseconds."}
{"id": "2507.22149", "categories": ["cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2507.22149", "abs": "https://arxiv.org/abs/2507.22149", "authors": ["Xianxuan Long", "Yao Fu", "Runchao Li", "Mu Sheng", "Haotian Yu", "Xiaotian Han", "Pan Li"], "title": "When Truthful Representations Flip Under Deceptive Instructions?", "comment": null, "summary": "Large language models (LLMs) tend to follow maliciously crafted instructions\nto generate deceptive responses, posing safety challenges. How deceptive\ninstructions alter the internal representations of LLM compared to truthful\nones remains poorly understood beyond output analysis. To bridge this gap, we\ninvestigate when and how these representations ``flip'', such as from truthful\nto deceptive, under deceptive versus truthful/neutral instructions. Analyzing\nthe internal representations of Llama-3.1-8B-Instruct and Gemma-2-9B-Instruct\non a factual verification task, we find the model's instructed True/False\noutput is predictable via linear probes across all conditions based on the\ninternal representation. Further, we use Sparse Autoencoders (SAEs) to show\nthat the Deceptive instructions induce significant representational shifts\ncompared to Truthful/Neutral representations (which are similar), concentrated\nin early-to-mid layers and detectable even on complex datasets. We also\nidentify specific SAE features highly sensitive to deceptive instruction and\nuse targeted visualizations to confirm distinct truthful/deceptive\nrepresentational subspaces. % Our analysis pinpoints layer-wise and\nfeature-level correlates of instructed dishonesty, offering insights for LLM\ndetection and control. Our findings expose feature- and layer-level signatures\nof deception, offering new insights for detecting and mitigating instructed\ndishonesty in LLMs."}
{"id": "2507.22066", "categories": ["cs.SE", "cs.CR"], "pdf": "https://arxiv.org/pdf/2507.22066", "abs": "https://arxiv.org/abs/2507.22066", "authors": ["Dylan Manuel", "Paul Rad"], "title": "CodableLLM: Automating Decompiled and Source Code Mapping for LLM Dataset Generation", "comment": null, "summary": "The generation of large, high-quality datasets for code understanding and\ngeneration remains a significant challenge, particularly when aligning\ndecompiled binaries with their original source code. To address this, we\npresent CodableLLM, a Python framework designed to automate the creation and\ncuration of datasets by mapping decompiled functions to their corresponding\nsource functions. This process enhances the alignment between decompiled and\nsource code representations, facilitating the development of large language\nmodels (LLMs) capable of understanding and generating code across multiple\nabstraction levels. CodableLLM supports multiple programming languages and\nintegrates with existing decompilers and parsers to streamline dataset\ngeneration. This paper presents the design and implementation of CodableLLM,\nevaluates its performance in dataset creation, and compares it to existing\ntools in the field. The results demonstrate that CodableLLM offers a robust and\nefficient solution for generating datasets tailored for code-focused LLMS."}
{"id": "2507.22197", "categories": ["cs.AI", "cs.CL", "cs.CY"], "pdf": "https://arxiv.org/pdf/2507.22197", "abs": "https://arxiv.org/abs/2507.22197", "authors": ["Matthieu Queloz"], "title": "Explainability Through Systematicity: The Hard Systematicity Challenge for Artificial Intelligence", "comment": "39 pages; final, published version", "summary": "This paper argues that explainability is only one facet of a broader ideal\nthat shapes our expectations towards artificial intelligence (AI).\nFundamentally, the issue is to what extent AI exhibits systematicity--not\nmerely in being sensitive to how thoughts are composed of recombinable\nconstituents, but in striving towards an integrated body of thought that is\nconsistent, coherent, comprehensive, and parsimoniously principled. This richer\nconception of systematicity has been obscured by the long shadow of the\n\"systematicity challenge\" to connectionism, according to which network\narchitectures are fundamentally at odds with what Fodor and colleagues termed\n\"the systematicity of thought.\" I offer a conceptual framework for thinking\nabout \"the systematicity of thought\" that distinguishes four senses of the\nphrase. I use these distinctions to defuse the perceived tension between\nsystematicity and connectionism and show that the conception of systematicity\nthat historically shaped our sense of what makes thought rational,\nauthoritative, and scientific is more demanding than the Fodorian notion. To\ndetermine whether we have reason to hold AI models to this ideal of\nsystematicity, I then argue, we must look to the rationales for systematization\nand explore to what extent they transfer to AI models. I identify five such\nrationales and apply them to AI. This brings into view the \"hard systematicity\nchallenge.\" However, the demand for systematization itself needs to be\nregulated by the rationales for systematization. This yields a dynamic\nunderstanding of the need to systematize thought, which tells us how systematic\nwe need AI models to be and when."}
{"id": "2507.22133", "categories": ["cs.CR", "cs.CL"], "pdf": "https://arxiv.org/pdf/2507.22133", "abs": "https://arxiv.org/abs/2507.22133", "authors": ["Michael Freenor", "Lauren Alvarez", "Milton Leal", "Lily Smith", "Joel Garrett", "Yelyzaveta Husieva", "Madeline Woodruff", "Ryan Miller", "Erich Kummerfeld", "Rafael Medeiros", "Sander Schulhoff"], "title": "Prompt Optimization and Evaluation for LLM Automated Red Teaming", "comment": "9 pages, 5 Figures, and 1 Appendix item", "summary": "Applications that use Large Language Models (LLMs) are becoming widespread,\nmaking the identification of system vulnerabilities increasingly important.\nAutomated Red Teaming accelerates this effort by using an LLM to generate and\nexecute attacks against target systems. Attack generators are evaluated using\nthe Attack Success Rate (ASR) the sample mean calculated over the judgment of\nsuccess for each attack. In this paper, we introduce a method for optimizing\nattack generator prompts that applies ASR to individual attacks. By repeating\neach attack multiple times against a randomly seeded target, we measure an\nattack's discoverability the expectation of the individual attack success. This\napproach reveals exploitable patterns that inform prompt optimization,\nultimately enabling more robust evaluation and refinement of generators."}
{"id": "2507.22070", "categories": ["cs.SE", "cs.CE", "cs.PL"], "pdf": "https://arxiv.org/pdf/2507.22070", "abs": "https://arxiv.org/abs/2507.22070", "authors": ["Y. Du"], "title": "Automated Test Data Generation for Enterprise Protobuf Systems: A Metaclass-Enhanced Statistical Approach", "comment": "7 pages", "summary": "Large-scale enterprise systems utilizing Protocol Buffers (protobuf) present\nsignificant challenges for performance testing, particularly when targeting\nintermediate business interfaces with complex nested data structures.\nTraditional test data generation approaches are inadequate for handling the\nintricate hierarchical and graph-like structures inherent in enterprise\nprotobuf schemas. This paper presents a novel test data generation framework\nthat leverages Python's metaclass system for dynamic type enhancement and\nstatistical analysis of production logs for realistic value domain extraction.\nOur approach combines automatic schema introspection, statistical value\ndistribution analysis, and recursive descent algorithms for handling deeply\nnested structures. Experimental evaluation on three real-world enterprise\nsystems demonstrates up to 95\\% reduction in test data preparation time and\n80\\% improvement in test coverage compared to existing approaches. The\nframework successfully handles protobuf structures with up to 15 levels of\nnesting and generates comprehensive test suites containing over 100,000 test\ncases within seconds."}
{"id": "2507.22281", "categories": ["cs.AI", "cs.CL"], "pdf": "https://arxiv.org/pdf/2507.22281", "abs": "https://arxiv.org/abs/2507.22281", "authors": ["Minsoo Kim", "Seung-won Hwang"], "title": "CoEx -- Co-evolving World-model and Exploration", "comment": null, "summary": "Planning in modern LLM agents relies on the utilization of LLM as an internal\nworld model, acquired during pretraining. However, existing agent designs fail\nto effectively assimilate new observations into dynamic updates of the world\nmodel. This reliance on the LLM's static internal world model is progressively\nprone to misalignment with the underlying true state of the world, leading to\nthe generation of divergent and erroneous plans. We introduce a hierarchical\nagent architecture, CoEx, in which hierarchical state abstraction allows LLM\nplanning to co-evolve with a dynamically updated model of the world. CoEx plans\nand interacts with the world by using LLM reasoning to orchestrate dynamic\nplans consisting of subgoals, and its learning mechanism continuously\nincorporates these subgoal experiences into a persistent world model in the\nform of a neurosymbolic belief state, comprising textual inferences and\ncode-based symbolic memory. We evaluate our agent across a diverse set of agent\nscenarios involving rich environments and complex tasks including ALFWorld,\nPDDL, and Jericho. Our experiments show that CoEx outperforms existing agent\nparadigms in planning and exploration."}
{"id": "2507.22160", "categories": ["cs.CR", "cs.AI", "cs.CL"], "pdf": "https://arxiv.org/pdf/2507.22160", "abs": "https://arxiv.org/abs/2507.22160", "authors": ["Yassine Rachidy", "Jihad Rbaiti", "Youssef Hmamouche", "Faissal Sehbaoui", "Amal El Fallah Seghrouchni"], "title": "Strategic Deflection: Defending LLMs from Logit Manipulation", "comment": "20 pages", "summary": "With the growing adoption of Large Language Models (LLMs) in critical areas,\nensuring their security against jailbreaking attacks is paramount. While\ntraditional defenses primarily rely on refusing malicious prompts, recent\nlogit-level attacks have demonstrated the ability to bypass these safeguards by\ndirectly manipulating the token-selection process during generation. We\nintroduce Strategic Deflection (SDeflection), a defense that redefines the\nLLM's response to such advanced attacks. Instead of outright refusal, the model\nproduces an answer that is semantically adjacent to the user's request yet\nstrips away the harmful intent, thereby neutralizing the attacker's harmful\nintent. Our experiments demonstrate that SDeflection significantly lowers\nAttack Success Rate (ASR) while maintaining model performance on benign\nqueries. This work presents a critical shift in defensive strategies, moving\nfrom simple refusal to strategic content redirection to neutralize advanced\nthreats."}
{"id": "2507.22071", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.22071", "abs": "https://arxiv.org/abs/2507.22071", "authors": ["Niels Glodny"], "title": "Analyzing and Evaluating the Behavior of Git Diff and Merge", "comment": "Bachelor's thesis", "summary": "Despite being widely used, the algorithms that enable collaboration with Git\nare not well understood. The diff and merge algorithms are particularly\ninteresting, as they could be applied in other contexts. In this thesis, I\ndocument the main functionalities of Git: how diffs are computed, how they are\nused to run merges, and how merges enable more complex operations. In the\nprocess, I show multiple unexpected behaviors in Git, including the following:\nThe histogram diff algorithm has pathological cases where a single-line change\ncan cause the entire rest of the file to be marked as changed. The default\nmerge strategy (ort) can result in merges requiring exponential time in the\nnumber of commits in the history. Merges and rebases are not commutative, and\neven when merges do not result in a conflict, the result is not specified but\ndepends on the diff algorithm used. And finally, sometimes when two sides of a\nmerge add different lines at the same position, the result is not a conflict,\nbut a merge containing both changes after each other, in arbitrary order."}
{"id": "2507.22326", "categories": ["cs.AI"], "pdf": "https://arxiv.org/pdf/2507.22326", "abs": "https://arxiv.org/abs/2507.22326", "authors": ["Qun Ma", "Xiao Xue", "Ming Zhang", "Yifan Shen", "Zihan Zhao"], "title": "An Explainable Emotion Alignment Framework for LLM-Empowered Agent in Metaverse Service Ecosystem", "comment": null, "summary": "Metaverse service is a product of the convergence between Metaverse and\nservice systems, designed to address service-related challenges concerning\ndigital avatars, digital twins, and digital natives within Metaverse. With the\nrise of large language models (LLMs), agents now play a pivotal role in\nMetaverse service ecosystem, serving dual functions: as digital avatars\nrepresenting users in the virtual realm and as service assistants (or NPCs)\nproviding personalized support. However, during the modeling of Metaverse\nservice ecosystems, existing LLM-based agents face significant challenges in\nbridging virtual-world services with real-world services, particularly\nregarding issues such as character data fusion, character knowledge\nassociation, and ethical safety concerns. This paper proposes an explainable\nemotion alignment framework for LLM-based agents in Metaverse Service\nEcosystem. It aims to integrate factual factors into the decision-making loop\nof LLM-based agents, systematically demonstrating how to achieve more\nrelational fact alignment for these agents. Finally, a simulation experiment in\nthe Offline-to-Offline food delivery scenario is conducted to evaluate the\neffectiveness of this framework, obtaining more realistic social emergence."}
{"id": "2507.22165", "categories": ["cs.CR", "cs.NI"], "pdf": "https://arxiv.org/pdf/2507.22165", "abs": "https://arxiv.org/abs/2507.22165", "authors": ["Gursimran Singh", "H. B. Acharya", "Minseok Kwon"], "title": "Programmable Data Planes for Network Security", "comment": "17th International Conference on Networks & Communications (NeTCoM\n  2025)", "summary": "The emergence of programmable data planes, and particularly switches\nsupporting the P4 language, has transformed network security by enabling\ncustomized, line-rate packet processing. These switches, originally intended\nfor flexible forwarding, now play a broader role: detecting and mitigating\nattacks such as DDoS and spoofing, enforcing next-generation firewall policies,\nand even supporting in-network cryptography and machine learning. These\ncapabilities are made possible by techniques such as recirculate-and-truncate\nand lookup-table precomputation, which work around architectural constraints\nlike limited memory and restricted instruction sets. In this paper, we\nsystematize recent advances in security applications built on programmable\nswitches, with an emphasis on the capabilities, challenges, and architectural\nworkarounds. We highlight the non-obvious design techniques that make complex\nin-network security functions feasible despite the constraints of the hardware\nplatform, and also comment on remaining issues and emerging research\ndirections."}
{"id": "2507.22080", "categories": ["cs.SE", "cs.AI", "cs.CL"], "pdf": "https://arxiv.org/pdf/2507.22080", "abs": "https://arxiv.org/abs/2507.22080", "authors": ["Qiushi Sun", "Jinyang Gong", "Lei Li", "Qipeng Guo", "Fei Yuan"], "title": "CodeEvo: Interaction-Driven Synthesis of Code-centric Data through Hybrid and Iterative Feedback", "comment": "Work in progress", "summary": "Acquiring high-quality instruction-code pairs is essential for training Large\nLanguage Models (LLMs) for code generation. Manually curated data is expensive\nand inherently limited in scale, motivating the development of code-centric\nsynthesis methods. Yet, current approaches either focus on augmenting existing\ncode or rely on predefined heuristics, both lacking rigorous data validation,\nwhich results in synthetic data that is ungrounded, repetitive, or overly\nsimplistic. Inspired by collaborative programming practices, we propose\nCodeEvo, a framework that synthesizes code data through iterative interactions\nbetween two LLM agents: a Coder, which generates candidate code and test cases\nbased on given instructions, and a Reviewer, which guides the synthesis process\nby producing new instructions and feedback. We further introduce a hybrid\nfeedback mechanism that combines compiler determinism with the generative\nflexibility of agents, enabling automatic quality control throughout synthesis.\nExtensive experiments demonstrate that models fine-tuned on CodeEvo data\nsignificantly outperform established baselines across code generation\nbenchmarks with various difficulties. In-depth analyses further provide\ninsights from multiple perspectives into effective code-centric data synthesis."}
{"id": "2507.22358", "categories": ["cs.AI", "cs.HC"], "pdf": "https://arxiv.org/pdf/2507.22358", "abs": "https://arxiv.org/abs/2507.22358", "authors": ["Hussein Mozannar", "Gagan Bansal", "Cheng Tan", "Adam Fourney", "Victor Dibia", "Jingya Chen", "Jack Gerrits", "Tyler Payne", "Matheus Kunzler Maldaner", "Madeleine Grunde-McLaughlin", "Eric Zhu", "Griffin Bassman", "Jacob Alber", "Peter Chang", "Ricky Loynd", "Friederike Niedtner", "Ece Kamar", "Maya Murad", "Rafah Hosn", "Saleema Amershi"], "title": "Magentic-UI: Towards Human-in-the-loop Agentic Systems", "comment": null, "summary": "AI agents powered by large language models are increasingly capable of\nautonomously completing complex, multi-step tasks using external tools. Yet,\nthey still fall short of human-level performance in most domains including\ncomputer use, software development, and research. Their growing autonomy and\nability to interact with the outside world, also introduces safety and security\nrisks including potentially misaligned actions and adversarial manipulation. We\nargue that human-in-the-loop agentic systems offer a promising path forward,\ncombining human oversight and control with AI efficiency to unlock productivity\nfrom imperfect systems. We introduce Magentic-UI, an open-source web interface\nfor developing and studying human-agent interaction. Built on a flexible\nmulti-agent architecture, Magentic-UI supports web browsing, code execution,\nand file manipulation, and can be extended with diverse tools via Model Context\nProtocol (MCP). Moreover, Magentic-UI presents six interaction mechanisms for\nenabling effective, low-cost human involvement: co-planning, co-tasking,\nmulti-tasking, action guards, and long-term memory. We evaluate Magentic-UI\nacross four dimensions: autonomous task completion on agentic benchmarks,\nsimulated user testing of its interaction capabilities, qualitative studies\nwith real users, and targeted safety assessments. Our findings highlight\nMagentic-UI's potential to advance safe and efficient human-agent\ncollaboration."}
{"id": "2507.22171", "categories": ["cs.CR", "cs.AI"], "pdf": "https://arxiv.org/pdf/2507.22171", "abs": "https://arxiv.org/abs/2507.22171", "authors": ["Zheng Zhang", "Peilin Zhao", "Deheng Ye", "Hao Wang"], "title": "Enhancing Jailbreak Attacks on LLMs via Persona Prompts", "comment": null, "summary": "Jailbreak attacks aim to exploit large language models (LLMs) by inducing\nthem to generate harmful content, thereby revealing their vulnerabilities.\nUnderstanding and addressing these attacks is crucial for advancing the field\nof LLM safety. Previous jailbreak approaches have mainly focused on direct\nmanipulations of harmful intent, with limited attention to the impact of\npersona prompts. In this study, we systematically explore the efficacy of\npersona prompts in compromising LLM defenses. We propose a genetic\nalgorithm-based method that automatically crafts persona prompts to bypass\nLLM's safety mechanisms. Our experiments reveal that: (1) our evolved persona\nprompts reduce refusal rates by 50-70% across multiple LLMs, and (2) these\nprompts demonstrate synergistic effects when combined with existing attack\nmethods, increasing success rates by 10-20%. Our code and data are available at\nhttps://github.com/CjangCjengh/Generic_Persona."}
{"id": "2507.22085", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.22085", "abs": "https://arxiv.org/abs/2507.22085", "authors": ["Vaani Goenka", "Aalok D. Thakkar"], "title": "BOOP: Write Right Code", "comment": null, "summary": "Novice programmers frequently adopt a syntax-specific and test-case-driven\napproach, writing code first and adjusting until programs compile and test\ncases pass, rather than developing correct solutions through systematic\nreasoning. AI coding tools exacerbate this challenge by providing syntactically\ncorrect but conceptually flawed solutions. In this paper, we introduce BOOP\n(Blueprint, Operations, OCaml, Proof), a structured framework requiring four\nmandatory phases: formal specification, language-agnostic algorithm\ndevelopment, implementation, and correctness proof. This shifts focus from\n``making code work'' to understanding why code is correct.\n  BOOP was implemented at our institution using a VS Code extension and\npreprocessor that enforces constraints and identifies counterproductive\npatterns. Initial evaluation shows improved algorithmic reasoning and reduced\ntrial-and-error debugging. Students reported better edge case understanding and\nproblem decomposition, though some initially found the format verbose.\nInstructors observed stronger foundational skills compared to traditional\napproaches."}
{"id": "2507.22359", "categories": ["cs.AI", "cs.CL"], "pdf": "https://arxiv.org/pdf/2507.22359", "abs": "https://arxiv.org/abs/2507.22359", "authors": ["Qianhong Guo", "Wei Xie", "Xiaofang Cai", "Enze Wang", "Shuoyoucheng Ma", "Kai Chen", "Xiaofeng Wang", "Baosheng Wang"], "title": "LLM-Crowdsourced: A Benchmark-Free Paradigm for Mutual Evaluation of Large Language Models", "comment": null, "summary": "Although large language models (LLMs) demonstrate remarkable capabilities\nacross various tasks, evaluating their capabilities remains a challenging task.\nExisting evaluation methods suffer from issues such as data contamination,\nblack-box operation, and subjective preference. These issues make it difficult\nto evaluate the LLMs' true capabilities comprehensively. To tackle these\nchallenges, we propose a novel benchmark-free evaluation paradigm,\nLLM-Crowdsourced. It utilizes LLMs to generate questions, answer independently,\nand evaluate mutually. This method integrates four key evaluation criteria:\ndynamic, transparent, objective, and professional, which existing evaluation\nmethods cannot satisfy simultaneously. Experiments on eight mainstream LLMs\nacross mathematics and programming verify the advantages of our method in\ndistinguishing LLM performance. Furthermore, our study reveals several novel\nfindings that are difficult for traditional methods to detect, including but\nnot limited to: (1) Gemini demonstrates the highest original and professional\nquestion-design capabilities among others; (2) Some LLMs exhibit\n''memorization-based answering'' by misrecognizing questions as familiar ones\nwith a similar structure; (3) LLM evaluation results demonstrate high\nconsistency (robustness)."}
{"id": "2507.22177", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2507.22177", "abs": "https://arxiv.org/abs/2507.22177", "authors": ["Tanzim Mahfuz", "Sudipta Paria", "Tasneem Suha", "Swarup Bhunia", "Prabuddha Chakraborty"], "title": "POLARIS: Explainable Artificial Intelligence for Mitigating Power Side-Channel Leakage", "comment": null, "summary": "Microelectronic systems are widely used in many sensitive applications (e.g.,\nmanufacturing, energy, defense). These systems increasingly handle sensitive\ndata (e.g., encryption key) and are vulnerable to diverse threats, such as,\npower side-channel attacks, which infer sensitive data through dynamic power\nprofile. In this paper, we present a novel framework, POLARIS for mitigating\npower side channel leakage using an Explainable Artificial Intelligence (XAI)\nguided masking approach. POLARIS uses an unsupervised process to automatically\nbuild a tailored training dataset and utilize it to train a masking model.The\nPOLARIS framework outperforms state-of-the-art mitigation solutions (e.g.,\nVALIANT) in terms of leakage reduction, execution time, and overhead across\nlarge designs."}
{"id": "2507.22086", "categories": ["cs.SE", "cs.AI", "cs.PL"], "pdf": "https://arxiv.org/pdf/2507.22086", "abs": "https://arxiv.org/abs/2507.22086", "authors": ["Honghua Dong", "Jiacheng Yang", "Xun Deng", "Yuhe Jiang", "Gennady Pekhimenko", "Fan Long", "Xujie Si"], "title": "TypyBench: Evaluating LLM Type Inference for Untyped Python Repositories", "comment": null, "summary": "Type inference for dynamic languages like Python is a persistent challenge in\nsoftware engineering. While large language models (LLMs) have shown promise in\ncode understanding, their type inference capabilities remain underexplored. We\nintroduce TypyBench, a benchmark designed to evaluate LLMs' type inference\nacross entire Python repositories. TypyBench features two novel metrics:\nTypeSim, which captures nuanced semantic relationships between predicted and\nground truth types, and TypeCheck, which assesses type consistency across\ncodebases. Our evaluation of various LLMs on a curated dataset of 50\nhigh-quality Python repositories reveals that, although LLMs achieve decent\nTypeSim scores, they struggle with complex nested types and exhibit significant\ntype consistency errors. These findings suggest that future research should\nshift focus from improving type similarity to addressing repository-level\nconsistency. TypyBench provides a foundation for this new direction, offering\ninsights into model performance across different type complexities and usage\ncontexts. Our code and data are available at\nhttps://github.com/typybench/typybench."}
{"id": "2507.22365", "categories": ["cs.AI", "cs.HC"], "pdf": "https://arxiv.org/pdf/2507.22365", "abs": "https://arxiv.org/abs/2507.22365", "authors": ["ZhaoBin Li", "Mark Steyvers"], "title": "Beyond Accuracy: How AI Metacognitive Sensitivity improves AI-assisted Decision Making", "comment": "26 pages, 5 figures, submitted to Decision Analysis", "summary": "In settings where human decision-making relies on AI input, both the\npredictive accuracy of the AI system and the reliability of its confidence\nestimates influence decision quality. We highlight the role of AI metacognitive\nsensitivity -- its ability to assign confidence scores that accurately\ndistinguish correct from incorrect predictions -- and introduce a theoretical\nframework for assessing the joint impact of AI's predictive accuracy and\nmetacognitive sensitivity in hybrid decision-making settings. Our analysis\nidentifies conditions under which an AI with lower predictive accuracy but\nhigher metacognitive sensitivity can enhance the overall accuracy of human\ndecision making. Finally, a behavioral experiment confirms that greater AI\nmetacognitive sensitivity improves human decision performance. Together, these\nfindings underscore the importance of evaluating AI assistance not only by\naccuracy but also by metacognitive sensitivity, and of optimizing both to\nachieve superior decision outcomes."}
{"id": "2507.22231", "categories": ["cs.CR", "cs.LG"], "pdf": "https://arxiv.org/pdf/2507.22231", "abs": "https://arxiv.org/abs/2507.22231", "authors": ["Ahmed Sabbah", "Radi Jarrar", "Samer Zein", "David Mohaisen"], "title": "Understanding Concept Drift with Deprecated Permissions in Android Malware Detection", "comment": "13 pages, 9 figures, 5 tables, under review", "summary": "Permission analysis is a widely used method for Android malware detection. It\ninvolves examining the permissions requested by an application to access\nsensitive data or perform potentially malicious actions. In recent years,\nvarious machine learning (ML) algorithms have been applied to Android malware\ndetection using permission-based features and feature selection techniques,\noften achieving high accuracy. However, these studies have largely overlooked\nimportant factors such as protection levels and the deprecation or restriction\nof permissions due to updates in the Android OS -- factors that can contribute\nto concept drift.\n  In this study, we investigate the impact of deprecated and restricted\npermissions on the performance of machine learning models. A large dataset\ncontaining 166 permissions was used, encompassing more than 70,000 malware and\nbenign applications. Various machine learning and deep learning algorithms were\nemployed as classifiers, along with different concept drift detection\nstrategies. The results suggest that Android permissions are highly effective\nfeatures for malware detection, with the exclusion of deprecated and restricted\npermissions having only a marginal impact on model performance. In some cases,\nsuch as with CNN, accuracy improved. Excluding these permissions also enhanced\nthe detection of concept drift using a year-to-year analysis strategy. Dataset\nbalancing further improved model performance, reduced low-accuracy instances,\nand enhanced concept drift detection via the Kolmogorov-Smirnov test."}
{"id": "2507.22223", "categories": ["cs.SE", "D.2; D.2.4; D.4.6; I.2.7"], "pdf": "https://arxiv.org/pdf/2507.22223", "abs": "https://arxiv.org/abs/2507.22223", "authors": ["Kiana Kiashemshaki", "Mohammad Jalili Torkamani", "Negin Mahmoudi"], "title": "Secure coding for web applications: Frameworks, challenges, and the role of LLMs", "comment": "11 pages, 5 figures, 3 tables, 6 listings", "summary": "Secure coding is a critical yet often overlooked practice in software\ndevelopment. Despite extensive awareness efforts, real-world adoption remains\ninconsistent due to organizational, educational, and technical barriers. This\npaper provides a comprehensive review of secure coding practices across major\nframeworks and domains, including web development, DevSecOps, and cloud\nsecurity. It introduces a structured framework comparison and categorizes\nthreats aligned with the OWASP Top 10. Additionally, we explore the rising role\nof Large Language Models (LLMs) in evaluating and recommending secure code,\npresenting a reproducible case study across four major vulnerability types.\nThis paper offers practical insights for researchers, developers, and educators\non integrating secure coding into real-world development processes."}
{"id": "2507.22423", "categories": ["cs.AI"], "pdf": "https://arxiv.org/pdf/2507.22423", "abs": "https://arxiv.org/abs/2507.22423", "authors": ["Kei-Sing Ng"], "title": "On the Definition of Intelligence", "comment": "Accepted at AGI-25", "summary": "To engineer AGI, we should first capture the essence of intelligence in a\nspecies-agnostic form that can be evaluated, while being sufficiently general\nto encompass diverse paradigms of intelligent behavior, including reinforcement\nlearning, generative models, classification, analogical reasoning, and\ngoal-directed decision-making. We propose a general criterion based on sample\nfidelity: intelligence is the ability, given sample(s) from a category, to\ngenerate sample(s) from the same category. We formalise this intuition as\n{\\epsilon}-category intelligence: it is {\\epsilon}-intelligent with respect to\na category if no chosen admissible distinguisher can separate generated from\noriginal samples beyond tolerance {\\epsilon}. We present the formal framework,\noutline empirical protocols, and discuss implications for evaluation, safety,\nand generalization."}
{"id": "2507.22239", "categories": ["cs.CR", "cs.AI", "cs.SY", "eess.SY"], "pdf": "https://arxiv.org/pdf/2507.22239", "abs": "https://arxiv.org/abs/2507.22239", "authors": ["Muhammad Sharshar", "Ahmad Mohammad Saber", "Davor Svetinovic", "Amr M. Youssef", "Deepa Kundur", "Ehab F. El-Saadany"], "title": "Large Language Model-Based Framework for Explainable Cyberattack Detection in Automatic Generation Control Systems", "comment": "Accepted Publication", "summary": "The increasing digitization of smart grids has improved operational\nefficiency but also introduced new cybersecurity vulnerabilities, such as False\nData Injection Attacks (FDIAs) targeting Automatic Generation Control (AGC)\nsystems. While machine learning (ML) and deep learning (DL) models have shown\npromise in detecting such attacks, their opaque decision-making limits operator\ntrust and real-world applicability. This paper proposes a hybrid framework that\nintegrates lightweight ML-based attack detection with natural language\nexplanations generated by Large Language Models (LLMs). Classifiers such as\nLightGBM achieve up to 95.13% attack detection accuracy with only 0.004 s\ninference latency. Upon detecting a cyberattack, the system invokes LLMs,\nincluding GPT-3.5 Turbo, GPT-4 Turbo, and GPT-4o mini, to generate\nhuman-readable explanation of the event. Evaluated on 100 test samples, GPT-4o\nmini with 20-shot prompting achieved 93% accuracy in identifying the attack\ntarget, a mean absolute error of 0.075 pu in estimating attack magnitude, and\n2.19 seconds mean absolute error (MAE) in estimating attack onset. These\nresults demonstrate that the proposed framework effectively balances real-time\ndetection with interpretable, high-fidelity explanations, addressing a critical\nneed for actionable AI in smart grid cybersecurity."}
{"id": "2507.22324", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2507.22324", "abs": "https://arxiv.org/abs/2507.22324", "authors": ["Cameron S. Movassaghi", "Amanda Momenzadeh", "Jesse G. Meyer"], "title": "From Articles to Code: On-Demand Generation of Core Algorithms from Scientific Publications", "comment": null, "summary": "Maintaining software packages imposes significant costs due to dependency\nmanagement, bug fixes, and versioning. We show that rich method descriptions in\nscientific publications can serve as standalone specifications for modern large\nlanguage models (LLMs), enabling on-demand code generation that could supplant\nhuman-maintained libraries. We benchmark state-of-the-art models\n(GPT-o4-mini-high, Gemini Pro 2.5, Claude Sonnet 4) by tasking them with\nimplementing a diverse set of core algorithms drawn from original publications.\nOur results demonstrate that current LLMs can reliably reproduce package\nfunctionality with performance indistinguishable from conventional libraries.\nThese findings foreshadow a paradigm shift toward flexible, on-demand code\ngeneration and away from static, human-maintained packages, which will result\nin reduced maintenance overhead by leveraging published articles as sufficient\ncontext for the automated implementation of analytical workflows."}
{"id": "2507.22432", "categories": ["cs.AI"], "pdf": "https://arxiv.org/pdf/2507.22432", "abs": "https://arxiv.org/abs/2507.22432", "authors": ["Zhe Yu", "Yiwei Lu", "Burkhard Schafer", "Zhe Lin"], "title": "Cross-Border Legal Adaptation of Autonomous Vehicle Design based on Logic and Non-monotonic Reasoning", "comment": "Accepted to appear in Proceedings of the 20th International\n  Conference on Artificial Intelligence and Law (ICAIL 2025)", "summary": "This paper focuses on the legal compliance challenges of autonomous vehicles\nin a transnational context. We choose the perspective of designers and try to\nprovide supporting legal reasoning in the design process. Based on\nargumentation theory, we introduce a logic to represent the basic properties of\nargument-based practical (normative) reasoning, combined with partial order\nsets of natural numbers to express priority. Finally, through case analysis of\nlegal texts, we show how the reasoning system we provide can help designers to\nadapt their design solutions more flexibly in the cross-border application of\nautonomous vehicles and to more easily understand the legal implications of\ntheir decisions."}
{"id": "2507.22304", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2507.22304", "abs": "https://arxiv.org/abs/2507.22304", "authors": ["Chetan Pathade"], "title": "Invisible Injections: Exploiting Vision-Language Models Through Steganographic Prompt Embedding", "comment": "14 Pages", "summary": "Vision-language models (VLMs) have revolutionized multimodal AI applications\nbut introduce novel security vulnerabilities that remain largely unexplored. We\npresent the first comprehensive study of steganographic prompt injection\nattacks against VLMs, where malicious instructions are invisibly embedded\nwithin images using advanced steganographic techniques. Our approach\ndemonstrates that current VLM architectures can inadvertently extract and\nexecute hidden prompts during normal image processing, leading to covert\nbehavioral manipulation. We develop a multi-domain embedding framework\ncombining spatial, frequency, and neural steganographic methods, achieving an\noverall attack success rate of 24.3% (plus or minus 3.2%, 95% CI) across\nleading VLMs including GPT-4V, Claude, and LLaVA, with neural steganography\nmethods reaching up to 31.8%, while maintaining reasonable visual\nimperceptibility (PSNR greater than 38 dB, SSIM greater than 0.94). Through\nsystematic evaluation on 12 diverse datasets and 8 state-of-the-art models, we\nreveal moderate but meaningful vulnerabilities in current VLM architectures and\npropose effective countermeasures. Our findings have significant implications\nfor VLM deployment in security-critical applications and highlight the need for\nproportionate multimodal AI security frameworks."}
{"id": "2507.22414", "categories": ["cs.SE", "D.2; I.2"], "pdf": "https://arxiv.org/pdf/2507.22414", "abs": "https://arxiv.org/abs/2507.22414", "authors": ["Sungmin Kang", "Haifeng Ruan", "Abhik Roychoudhury"], "title": "AutoCodeSherpa: Symbolic Explanations in AI Coding Agents", "comment": null, "summary": "Large Language Model (LLM) agents autonomously use external tools on top of\none or more LLMs to accomplish specific tasks. Lately LLM agents for software\nengineering tasks have become popular. These agents can benefit from the use of\nprogram analysis tools working on program representations. This is demonstrated\nby existing agentic AI solutions such as AutoCodeRover or SpecRover which\nperform automated program repair. Specifically the goal of these works is to\nuse program analysis to improve the patch quality. These agents are currently\nbeing used to automatically fix static analysis issues from the widely used\nSonarQube static analyzer.\n  Nevertheless, for the agents to be deployed in a production environment,\nagents need to suggest software artifacts, such as patches, with evidence and\nwith high confidence. In this work, we provide a workflow where an agent\nprovides explanations of the bug in the form of symbolic formulae. The\nexplanations are in the form of input conditions, infection conditions and\noutput conditions, implemented as property based tests (PBT) and\nprogram-internal symbolic expressions. These can help in human developer\ncognition of the agent outputs as well as in achieving completely automated\nagentic workflows for software. The human developer can benefit from the input\ncondition, represented as a PBT, to generate various concrete inputs showing a\ngiven issue. Furthermore, since the PBTs are executable, our explanations are\nexecutable as well. We can thus also use the explanations in a completely\nautomated issue resolution environment for accepting or rejecting the patches\nthat are suggested by patching agents such as AutoCodeRover. Finally, as\nagentic AI approaches continue to develop, the program analysis driven\nexplanations can be provided to other LLM-based repair techniques such as\nAgentless to improve their output."}
{"id": "2507.22440", "categories": ["cs.AI", "cs.NE"], "pdf": "https://arxiv.org/pdf/2507.22440", "abs": "https://arxiv.org/abs/2507.22440", "authors": ["Yiya Diao", "Changhe Li", "Sanyou Zeng", "Xinye Cai", "Wenjian Luo", "Shengxiang Yang", "Carlos A. Coello Coello"], "title": "Nearest-Better Network for Visualizing and Analyzing Combinatorial Optimization Problems: A Unified Tool", "comment": null, "summary": "The Nearest-Better Network (NBN) is a powerful method to visualize sampled\ndata for continuous optimization problems while preserving multiple landscape\nfeatures. However, the calculation of NBN is very time-consuming, and the\nextension of the method to combinatorial optimization problems is challenging\nbut very important for analyzing the algorithm's behavior. This paper provides\na straightforward theoretical derivation showing that the NBN network\nessentially functions as the maximum probability transition network for\nalgorithms. This paper also presents an efficient NBN computation method with\nlogarithmic linear time complexity to address the time-consuming issue. By\napplying this efficient NBN algorithm to the OneMax problem and the Traveling\nSalesman Problem (TSP), we have made several remarkable discoveries for the\nfirst time: The fitness landscape of OneMax exhibits neutrality, ruggedness,\nand modality features. The primary challenges of TSP problems are ruggedness,\nmodality, and deception. Two state-of-the-art TSP algorithms (i.e., EAX and\nLKH) have limitations when addressing challenges related to modality and\ndeception, respectively. LKH, based on local search operators, fails when there\nare deceptive solutions near global optima. EAX, which is based on a single\npopulation, can efficiently maintain diversity. However, when multiple\nattraction basins exist, EAX retains individuals within multiple basins\nsimultaneously, reducing inter-basin interaction efficiency and leading to\nalgorithm's stagnation."}
{"id": "2507.22306", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2507.22306", "abs": "https://arxiv.org/abs/2507.22306", "authors": ["Sahan Sanjaya", "Aruna Jayasena", "Prabhat Mishra"], "title": "SleepWalk: Exploiting Context Switching and Residual Power for Physical Side-Channel Attacks", "comment": null, "summary": "Context switching is utilized by operating systems to change the execution\ncontext between application programs. It involves saving and restoring the\nstates of multiple registers and performing a pipeline flush to remove any\npre-fetched instructions, leading to a higher instantaneous power consumption\ncompared to typical program execution. In this paper, we introduce a physical\npower side-channel leakage source that exploits the power spike observed during\na context switch, triggered by the inbuilt sleep function of the system kernel.\nWe observed that this power spike directly correlates with both the power\nconsumption during context switching and the residual power consumption of the\npreviously executed program. Notably, the persistence of residual power\nsignatures from previous workloads extends the scope of this side-channel\nbeyond extracting the data in registers during the context switch. Unlike\ntraditional approaches that require analyzing full power traces, applying\ncomplex preprocessing, or relying on external synchronization triggers, this\nnovel technique leverages only the amplitude of a single power spike,\nsignificantly simplifying the attack. We developed a power model to illustrate\nthe feasibility of mounting end-to-end side-channel attacks using the\nsleep-induced power spikes. Experimental evaluation demonstrates that our\nframework can successfully perform cryptographic key recovery for both AES and\nSIKE implementations on Broadcom BCM2711."}
{"id": "2507.22442", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.22442", "abs": "https://arxiv.org/abs/2507.22442", "authors": ["Yukai Zhao", "Shaohua Wang", "Jue Wang", "Xing Hu", "Xin Xia"], "title": "Ensemble Fuzzing with Dynamic Resource Scheduling and Multidimensional Seed Evaluation", "comment": "first submit", "summary": "Fuzzing is widely used for detecting bugs and vulnerabilities, with various\ntechniques proposed to enhance its effectiveness. To combine the advantages of\nmultiple technologies, researchers proposed ensemble fuzzing, which integrates\nmultiple base fuzzers. Despite promising results, state-of-the-art ensemble\nfuzzing techniques face limitations in resource scheduling and performance\nevaluation, leading to unnecessary resource waste. In this paper, we propose\nLegion, a novel ensemble fuzzing framework that dynamically schedules resources\nduring the ensemble fuzzing campaign. We designed a novel resource scheduling\nalgorithm based on the upper confidence bound algorithm to reduce the resource\nconsumption of ineffective base fuzzers. Additionally, we introduce a\nmultidimensional seed evaluation strategy, which considers multiple metrics to\nachieve more comprehensive fine-grained performance evaluation. We implemented\nLegion as a prototype tool and evaluated its effectiveness on Google's\nfuzzer-test-suite as well as real-world open-source projects. Results show that\nLegion outperforms existing state-of-the-art base fuzzers and ensemble fuzzing\ntechniques, detecting 20 vulnerabilities in real-world open-source\nprojects-five previously unknown and three classified as CVEs."}
{"id": "2507.22504", "categories": ["cs.AI"], "pdf": "https://arxiv.org/pdf/2507.22504", "abs": "https://arxiv.org/abs/2507.22504", "authors": ["Hongyan Cheng", "Chengzhang Yu", "Yanshu Shi", "Chiyue Wang", "Cong Liu", "Zhanpeng Jin"], "title": "Collaborative Medical Triage under Uncertainty: A Multi-Agent Dynamic Matching Approach", "comment": "10 pages, 8 figures, 2 table", "summary": "The post-pandemic surge in healthcare demand, coupled with critical nursing\nshortages, has placed unprecedented pressure on emergency department triage\nsystems, necessitating innovative AI-driven solutions. We present a multi-agent\ninteractive intelligent system for medical triage that addresses three\nfundamental challenges in current AI-based triage systems: insufficient medical\nspecialization leading to hallucination-induced misclassifications,\nheterogeneous department structures across healthcare institutions, and\ninefficient detail-oriented questioning that impedes rapid triage decisions.\nOur system employs three specialized agents - RecipientAgent, InquirerAgent,\nand DepartmentAgent - that collaborate through structured inquiry mechanisms\nand department-specific guidance rules to transform unstructured patient\nsymptoms into accurate department recommendations. To ensure robust evaluation,\nwe constructed a comprehensive Chinese medical triage dataset from a medical\nwebsite, comprising 3,360 real-world cases spanning 9 primary departments and\n62 secondary departments. Through systematic data imputation using large\nlanguage models, we address the prevalent issue of incomplete medical records\nin real-world data. Experimental results demonstrate that our multi-agent\nsystem achieves 89.2% accuracy in primary department classification and 73.9%\naccuracy in secondary department classification after four rounds of patient\ninteraction. The system's pattern-matching-based guidance mechanisms enable\nefficient adaptation to diverse hospital configurations while maintaining high\ntriage accuracy. Our work provides a scalable framework for deploying\nAI-assisted triage systems that can accommodate the organizational\nheterogeneity of healthcare institutions while ensuring clinically sound\ndecision-making."}
{"id": "2507.22347", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2507.22347", "abs": "https://arxiv.org/abs/2507.22347", "authors": ["Alexander Goldberg", "Giulia Fanti", "Nihar Shah", "Zhiwei Steven Wu"], "title": "Benchmarking Fraud Detectors on Private Graph Data", "comment": null, "summary": "We introduce the novel problem of benchmarking fraud detectors on private\ngraph-structured data. Currently, many types of fraud are managed in part by\nautomated detection algorithms that operate over graphs. We consider the\nscenario where a data holder wishes to outsource development of fraud detectors\nto third parties (e.g., vendors or researchers). The third parties submit their\nfraud detectors to the data holder, who evaluates these algorithms on a private\ndataset and then publicly communicates the results. We propose a realistic\nprivacy attack on this system that allows an adversary to de-anonymize\nindividuals' data based only on the evaluation results. In simulations of a\nprivacy-sensitive benchmark for facial recognition algorithms by the National\nInstitute of Standards and Technology (NIST), our attack achieves near perfect\naccuracy in identifying whether individuals' data is present in a private\ndataset, with a True Positive Rate of 0.98 at a False Positive Rate of 0.00. We\nthen study how to benchmark algorithms while satisfying a formal differential\nprivacy (DP) guarantee. We empirically evaluate two classes of solutions:\nsubsample-and-aggregate and DP synthetic graph data. We demonstrate through\nextensive experiments that current approaches do not provide utility when\nguaranteeing DP. Our results indicate that the error arising from DP trades off\nbetween bias from distorting graph structure and variance from adding random\nnoise. Current methods lie on different points along this bias-variance\ntrade-off, but more complex methods tend to require high-variance noise\naddition, undermining utility."}
{"id": "2507.22538", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.22538", "abs": "https://arxiv.org/abs/2507.22538", "authors": ["Matilde Gargiani", "Robin Sieber", "Philip Pawlowsky", "John Lygeros"], "title": "Inside madupite: Technical Design and Performance", "comment": null, "summary": "In this work, we introduce and benchmark madupite, a newly proposed\nhigh-performance solver designed for large-scale discounted infinite-horizon\nMarkov decision processes with finite state and action spaces. After a brief\noverview of the class of mathematical optimization methods on which madupite\nrelies, we provide details on implementation choices, technical design and\ndeployment. We then demonstrate its scalability and efficiency by showcasing\nits performance on the solution of Markov decision processes arising from\ndifferent application areas, including epidemiology and classical control.\nMadupite sets a new standard as, to the best of our knowledge, it is the only\nsolver capable of efficiently computing exact solutions for large-scale Markov\ndecision processes, even when these exceed the memory capacity of modern\nlaptops and operate in near-undiscounted settings. This is possible as madupite\ncan work in a fully distributed manner and therefore leverage the memory\nstorage and computation capabilities of modern high-performance computing\nclusters. This key feature enables the solver to efficiently handle problems of\nmedium to large size in an exact manner instead of necessarily resorting to\nfunction approximations. Moreover, madupite is unique in allowing users to\ncustomize the solution algorithm to better exploit the specific structure of\ntheir problem, significantly accelerating convergence especially in\nlarge-discount factor settings. Overall, madupite represents a significant\nadvancement, offering unmatched scalability and flexibility in solving\nlarge-scale Markov decision processes."}
{"id": "2507.22606", "categories": ["cs.AI"], "pdf": "https://arxiv.org/pdf/2507.22606", "abs": "https://arxiv.org/abs/2507.22606", "authors": ["Yaolun Zhang", "Xiaogeng Liu", "Chaowei Xiao"], "title": "MetaAgent: Automatically Constructing Multi-Agent Systems Based on Finite State Machines", "comment": "ICML 2025", "summary": "Large Language Models (LLMs) have demonstrated the ability to solve a wide\nrange of practical tasks within multi-agent systems. However, existing\nhuman-designed multi-agent frameworks are typically limited to a small set of\npre-defined scenarios, while current automated design methods suffer from\nseveral limitations, such as the lack of tool integration, dependence on\nexternal training data, and rigid communication structures. In this paper, we\npropose MetaAgent, a finite state machine based framework that can\nautomatically generate a multi-agent system. Given a task description,\nMetaAgent will design a multi-agent system and polish it through an\noptimization algorithm. When the multi-agent system is deployed, the finite\nstate machine will control the agent's actions and the state transitions. To\nevaluate our framework, we conduct experiments on both text-based tasks and\npractical tasks. The results indicate that the generated multi-agent system\nsurpasses other auto-designed methods and can achieve a comparable performance\nwith the human-designed multi-agent system, which is optimized for those\nspecific tasks."}
{"id": "2507.22371", "categories": ["cs.CR", "cs.AI", "cs.SE"], "pdf": "https://arxiv.org/pdf/2507.22371", "abs": "https://arxiv.org/abs/2507.22371", "authors": ["Lei Yu", "Shiqi Cheng", "Zhirong Huang", "Jingyuan Zhang", "Chenjie Shen", "Junyi Lu", "Li Yang", "Fengjun Zhang", "Jiajia Ma"], "title": "SAEL: Leveraging Large Language Models with Adaptive Mixture-of-Experts for Smart Contract Vulnerability Detection", "comment": "Accepted to ICSME 2025", "summary": "With the increasing security issues in blockchain, smart contract\nvulnerability detection has become a research focus. Existing vulnerability\ndetection methods have their limitations: 1) Static analysis methods struggle\nwith complex scenarios. 2) Methods based on specialized pre-trained models\nperform well on specific datasets but have limited generalization capabilities.\nIn contrast, general-purpose Large Language Models (LLMs) demonstrate\nimpressive ability in adapting to new vulnerability patterns. However, they\noften underperform on specific vulnerability types compared to methods based on\nspecialized pre-trained models. We also observe that explanations generated by\ngeneral-purpose LLMs can provide fine-grained code understanding information,\ncontributing to improved detection performance.\n  Inspired by these observations, we propose SAEL, an LLM-based framework for\nsmart contract vulnerability detection. We first design targeted prompts to\nguide LLMs in identifying vulnerabilities and generating explanations, which\nserve as prediction features. Next, we apply prompt-tuning on CodeT5 and T5 to\nprocess contract code and explanations, enhancing task-specific performance. To\ncombine the strengths of each approach, we introduce an Adaptive\nMixture-of-Experts architecture. This dynamically adjusts feature weights via a\nGating Network, which selects relevant features using TopK filtering and\nSoftmax normalization, and incorporates a Multi-Head Self-Attention mechanism\nto enhance cross-feature relationships. This design enables effective\nintegration of LLM predictions, explanation features, and code features through\ngradient optimization. The loss function jointly considers both independent\nfeature performance and overall weighted predictions. Experiments show that\nSAEL outperforms existing methods across various vulnerabilities."}
{"id": "2507.22580", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2507.22580", "abs": "https://arxiv.org/abs/2507.22580", "authors": ["Marcos Fuster-Pena", "David de-Fitero-Dominguez", "Antonio Garcia-Cabot", "Eva Garcia-Lopez"], "title": "RePaCA: Leveraging Reasoning Large Language Models for Static Automated Patch Correctness Assessment", "comment": null, "summary": "Automated Program Repair (APR) seeks to automatically correct software bugs\nwithout requiring human intervention. However, existing tools tend to generate\npatches that satisfy test cases without fixing the underlying bug, those are\nknown as overfitting patches. To address this issue, Automated Patch\nCorrectness Assessment (APCA) attempts to identify overfitting patches\ngenerated by APR tools. It can be solved as a static approach, meaning that no\nadditional information is needed beyond the original and fixed code snippets.\nCurrent static techniques often struggle with reliability, flexibility and\ntransparency. To address these issues, we introduce RePaCA, a novel static APCA\ntechnique that leverages Large Language Models (LLMs) specialized in thinking\ntasks. Our model is prompted with both buggy and fixed code snippets and guided\nto generate a Chain of Thought that analyses code differences, reasons about\nhow the patch addresses the root cause, and ultimately provides a binary\nclassification: correct or overfitting. To enhance these reasoning capabilities\nfor the APCA task specifically, the LLM is finetuned using Reinforcement\nLearning with the Group Relative Policy Optimization algorithm. When evaluated\non a standard Defects4J-derived test, our approach achieves state-of-the-art\nperformance, with 83.1% accuracy and an 84.8% F1-score. Furthermore, our model\ndemonstrates superior generalization capabilities when trained on different\ndatasets, outperforming the leading technique. This reasoning capability also\nprovides enhanced explainability for the patch assessment. These findings\nunderscore the considerable promise of finetuned, reasoning LLMs to advance\nstatic APCA by enhancing accuracy, generalization, and explainability."}
{"id": "2507.22619", "categories": ["cs.AI"], "pdf": "https://arxiv.org/pdf/2507.22619", "abs": "https://arxiv.org/abs/2507.22619", "authors": ["Sebastian Monka", "Irlan Grangel-González", "Stefan Schmid", "Lavdim Halilaj", "Marc Rickart", "Oliver Rudolph", "Rui Dias"], "title": "Enhancing Manufacturing Knowledge Access with LLMs and Context-aware Prompting", "comment": "European Conference on Artificial Intelligence (ECAI) 2024", "summary": "Knowledge graphs (KGs) have transformed data management within the\nmanufacturing industry, offering effective means for integrating disparate data\nsources through shared and structured conceptual schemas. However, harnessing\nthe power of KGs can be daunting for non-experts, as it often requires\nformulating complex SPARQL queries to retrieve specific information. With the\nadvent of Large Language Models (LLMs), there is a growing potential to\nautomatically translate natural language queries into the SPARQL format, thus\nbridging the gap between user-friendly interfaces and the sophisticated\narchitecture of KGs. The challenge remains in adequately informing LLMs about\nthe relevant context and structure of domain-specific KGs, e.g., in\nmanufacturing, to improve the accuracy of generated queries. In this paper, we\nevaluate multiple strategies that use LLMs as mediators to facilitate\ninformation retrieval from KGs. We focus on the manufacturing domain,\nparticularly on the Bosch Line Information System KG and the I40 Core\nInformation Model. In our evaluation, we compare various approaches for feeding\nrelevant context from the KG to the LLM and analyze their proficiency in\ntransforming real-world questions into SPARQL queries. Our findings show that\nLLMs can significantly improve their performance on generating correct and\ncomplete queries when provided only the adequate context of the KG schema. Such\ncontext-aware prompting techniques help LLMs to focus on the relevant parts of\nthe ontology and reduce the risk of hallucination. We anticipate that the\nproposed techniques help LLMs to democratize access to complex data\nrepositories and empower informed decision-making in manufacturing settings."}
{"id": "2507.22447", "categories": ["cs.CR", "cs.LG"], "pdf": "https://arxiv.org/pdf/2507.22447", "abs": "https://arxiv.org/abs/2507.22447", "authors": ["Zhihong Liang", "Xin Wang", "Zhenhuang Hu", "Liangliang Song", "Lin Chen", "Jingjing Guo", "Yanbin Wang", "Ye Tian"], "title": "Breaking Obfuscation: Cluster-Aware Graph with LLM-Aided Recovery for Malicious JavaScript Detection", "comment": null, "summary": "With the rapid expansion of web-based applications and cloud services,\nmalicious JavaScript code continues to pose significant threats to user\nprivacy, system integrity, and enterprise security. But, detecting such threats\nremains challenging due to sophisticated code obfuscation techniques and\nJavaScript's inherent language characteristics, particularly its nested closure\nstructures and syntactic flexibility. In this work, we propose DeCoda, a hybrid\ndefense framework that combines large language model (LLM)-based deobfuscation\nwith code graph learning: (1) We first construct a sophisticated\nprompt-learning pipeline with multi-stage refinement, where the LLM\nprogressively reconstructs the original code structure from obfuscated inputs\nand then generates normalized Abstract Syntax Tree (AST) representations; (2)\nIn JavaScript ASTs, dynamic typing scatters semantically similar nodes while\ndeeply nested functions fracture scope capturing, introducing structural noise\nand semantic ambiguity. To address these challenges, we then propose to learn\nhierarchical code graph representations via a Cluster-wise Graph that\nsynergistically integrates graph transformer network, node clustering, and\nnode-to-cluster attention to simultaneously capture both local node-level\nsemantics and global cluster-induced structural relationships from AST graph.\nExperimental results demonstrate that our method achieves F1-scores of 94.64%\nand 97.71% on two benchmark datasets, demonstrating absolute improvements of\n10.74% and 13.85% over state-of-the-art baselines. In false-positive control\nevaluation at fixed FPR levels (0.0001, 0.001, 0.01), our approach delivers\n4.82, 5.91, and 2.53 higher TPR respectively compared to the best-performing\nbaseline. These results highlight the effectiveness of LLM-based deobfuscation\nand underscore the importance of modeling cluster-level relationships in\ndetecting malicious code."}
{"id": "2507.22610", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2507.22610", "abs": "https://arxiv.org/abs/2507.22610", "authors": ["Ali Asgari", "Milan de Koning", "Pouria Derakhshanfar", "Annibale Panichella"], "title": "Metamorphic Testing of Deep Code Models: A Systematic Literature Review", "comment": null, "summary": "Large language models and deep learning models designed for code intelligence\nhave revolutionized the software engineering field due to their ability to\nperform various code-related tasks. These models can process source code and\nsoftware artifacts with high accuracy in tasks such as code completion, defect\ndetection, and code summarization; therefore, they can potentially become an\nintegral part of modern software engineering practices. Despite these\ncapabilities, robustness remains a critical quality attribute for deep-code\nmodels as they may produce different results under varied and adversarial\nconditions (e.g., variable renaming). Metamorphic testing has become a widely\nused approach to evaluate models' robustness by applying semantic-preserving\ntransformations to input programs and analyzing the stability of model outputs.\nWhile prior research has explored testing deep learning models, this systematic\nliterature review focuses specifically on metamorphic testing for deep code\nmodels. By studying 45 primary papers, we analyze the transformations,\ntechniques, and evaluation methods used to assess robustness. Our review\nsummarizes the current landscape, identifying frequently evaluated models,\nprogramming tasks, datasets, target languages, and evaluation metrics, and\nhighlights key challenges and future directions for advancing the field."}
{"id": "2507.22774", "categories": ["cs.AI"], "pdf": "https://arxiv.org/pdf/2507.22774", "abs": "https://arxiv.org/abs/2507.22774", "authors": ["Thomas Eiter", "Tobias Geibinger", "Tobias Kaminski", "Nysret Musliu", "Johannes Oetsch"], "title": "ASP-FZN: A Translation-based Constraint Answer Set Solver", "comment": "Presented at the 41st International Conference on Logic Programming\n  (ICLP 2025)", "summary": "We present the solver asp-fzn for Constraint Answer Set Programming (CASP),\nwhich extends ASP with linear constraints. Our approach is based on translating\nCASP programs into the solver-independent FlatZinc language that supports\nseveral Constraint Programming and Integer Programming backend solvers. Our\nsolver supports a rich language of linear constraints, including some common\nglobal constraints. As for evaluation, we show that asp-fzn is competitive with\nstate-of-the-art ASP solvers on benchmarks taken from past ASP competitions.\nFurthermore, we evaluate it on several CASP problems from the literature and\ncompare its performance with clingcon, which is a prominent CASP solver that\nsupports most of the asp-fzn language. The performance of asp-fzn is very\npromising as it is already competitive on plain ASP and even outperforms\nclingcon on some CASP benchmarks."}
{"id": "2507.22611", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2507.22611", "abs": "https://arxiv.org/abs/2507.22611", "authors": ["Chunyi Zhang", "Fengjiao Dou", "Xiaoqi Li"], "title": "DoS Attacks and Defense Technologies in Blockchain Systems: A Hierarchical Analysis", "comment": null, "summary": "Blockchain technology is widely used in various fields due to its ability to\nprovide decentralization and trustless security. This is a fundamental\nunderstanding held by many advocates, but it is misunderstood, leading\nparticipants to fail to recognize the limitations of the security that\nblockchain can provide. Among all current network attacks, Denial of Service\n(DoS) attacks pose significant threats due to their ease of execution and\ndestructive potential. This paper, based on the blockchain architecture\nhierarchy, categorizes and organizes existing DoS attacks, with a focus on\nexplaining the principles and methods of contract layer and consensus layer DoS\nattacks. Furthermore, this paper comprehensively analyzes and compares commonly\nused detection methods and defense technologies, which will contribute to\nstrengthening the security and stability of blockchain systems and promoting\nfurther innovation and application of blockchain systems."}
{"id": "2507.22659", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2507.22659", "abs": "https://arxiv.org/abs/2507.22659", "authors": ["Sabrina Kaniewski", "Fabian Schmidt", "Markus Enzweiler", "Michael Menth", "Tobias Heer"], "title": "A Systematic Literature Review on Detecting Software Vulnerabilities with Large Language Models", "comment": "36 pages + 17 pages references, 6 tables, 10 figures", "summary": "The increasing adoption of Large Language Models (LLMs) in software\nengineering has sparked interest in their use for software vulnerability\ndetection. However, the rapid development of this field has resulted in a\nfragmented research landscape, with diverse studies that are difficult to\ncompare due to differences in, e.g., system designs and dataset usage. This\nfragmentation makes it difficult to obtain a clear overview of the\nstate-of-the-art or compare and categorize studies meaningfully. In this work,\nwe present a comprehensive systematic literature review (SLR) of LLM-based\nsoftware vulnerability detection. We analyze 227 studies published between\nJanuary 2020 and June 2025, categorizing them by task formulation, input\nrepresentation, system architecture, and adaptation techniques. Further, we\nanalyze the datasets used, including their characteristics, vulnerability\ncoverage, and diversity. We present a fine-grained taxonomy of vulnerability\ndetection approaches, identify key limitations, and outline actionable future\nresearch opportunities. By providing a structured overview of the field, this\nreview improves transparency and serves as a practical guide for researchers\nand practitioners aiming to conduct more comparable and reproducible research.\nWe publicly release all artifacts and maintain a living repository of LLM-based\nsoftware vulnerability detection studies."}
{"id": "2507.22782", "categories": ["cs.AI", "cs.LG", "I.2.0; I.2.8"], "pdf": "https://arxiv.org/pdf/2507.22782", "abs": "https://arxiv.org/abs/2507.22782", "authors": ["Hugo Garrido-Lestache", "Jeremy Kedziora"], "title": "Enhancing Multi-Agent Collaboration with Attention-Based Actor-Critic Policies", "comment": "8 pages", "summary": "This paper introduces Team-Attention-Actor-Critic (TAAC), a reinforcement\nlearning algorithm designed to enhance multi-agent collaboration in cooperative\nenvironments. TAAC employs a Centralized Training/Centralized Execution scheme\nincorporating multi-headed attention mechanisms in both the actor and critic.\nThis design facilitates dynamic, inter-agent communication, allowing agents to\nexplicitly query teammates, thereby efficiently managing the exponential growth\nof joint-action spaces while ensuring a high degree of collaboration. We\nfurther introduce a penalized loss function which promotes diverse yet\ncomplementary roles among agents. We evaluate TAAC in a simulated soccer\nenvironment against benchmark algorithms representing other multi-agent\nparadigms, including Proximal Policy Optimization and Multi-Agent\nActor-Attention-Critic. We find that TAAC exhibits superior performance and\nenhanced collaborative behaviors across a variety of metrics (win rates, goal\ndifferentials, Elo ratings, inter-agent connectivity, balanced spatial\ndistributions, and frequent tactical interactions such as ball possession\nswaps)."}
{"id": "2507.22617", "categories": ["cs.CR", "cs.CV"], "pdf": "https://arxiv.org/pdf/2507.22617", "abs": "https://arxiv.org/abs/2507.22617", "authors": ["Yiting Qu", "Ziqing Yang", "Yihan Ma", "Michael Backes", "Savvas Zannettou", "Yang Zhang"], "title": "Hate in Plain Sight: On the Risks of Moderating AI-Generated Hateful Illusions", "comment": "Accepted at ICCV 2025", "summary": "Recent advances in text-to-image diffusion models have enabled the creation\nof a new form of digital art: optical illusions--visual tricks that create\ndifferent perceptions of reality. However, adversaries may misuse such\ntechniques to generate hateful illusions, which embed specific hate messages\ninto harmless scenes and disseminate them across web communities. In this work,\nwe take the first step toward investigating the risks of scalable hateful\nillusion generation and the potential for bypassing current content moderation\nmodels. Specifically, we generate 1,860 optical illusions using Stable\nDiffusion and ControlNet, conditioned on 62 hate messages. Of these, 1,571 are\nhateful illusions that successfully embed hate messages, either overtly or\nsubtly, forming the Hateful Illusion dataset. Using this dataset, we evaluate\nthe performance of six moderation classifiers and nine vision language models\n(VLMs) in identifying hateful illusions. Experimental results reveal\nsignificant vulnerabilities in existing moderation models: the detection\naccuracy falls below 0.245 for moderation classifiers and below 0.102 for VLMs.\nWe further identify a critical limitation in their vision encoders, which\nmainly focus on surface-level image details while overlooking the secondary\nlayer of information, i.e., hidden messages. To address this risk, we explore\npreliminary mitigation measures and identify the most effective approaches from\nthe perspectives of image transformations and training-level strategies."}
{"id": "2507.22664", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2507.22664", "abs": "https://arxiv.org/abs/2507.22664", "authors": ["Mashal Afzal Memon", "Gianluca Filippone", "Gian Luca Scoccia", "Marco Autili", "Paola Inverardi"], "title": "RobEthiChor: Automated Context-aware Ethics-based Negotiation for Autonomous Robots", "comment": null, "summary": "The presence of autonomous systems is growing at a fast pace and it is\nimpacting many aspects of our lives. Designed to learn and act independently,\nthese systems operate and perform decision-making without human intervention.\nHowever, they lack the ability to incorporate users' ethical preferences, which\nare unique for each individual in society and are required to personalize the\ndecision-making processes. This reduces user trust and prevents autonomous\nsystems from behaving according to the moral beliefs of their end-users. When\nmultiple systems interact with differing ethical preferences, they must\nnegotiate to reach an agreement that satisfies the ethical beliefs of all the\nparties involved and adjust their behavior consequently. To address this\nchallenge, this paper proposes RobEthiChor, an approach that enables autonomous\nsystems to incorporate user ethical preferences and contextual factors into\ntheir decision-making through ethics-based negotiation. RobEthiChor features a\ndomain-agnostic reference architecture for designing autonomous systems capable\nof ethic-based negotiating. The paper also presents RobEthiChor-Ros, an\nimplementation of RobEthiChor within the Robot Operating System (ROS), which\ncan be deployed on robots to provide them with ethics-based negotiation\ncapabilities. To evaluate our approach, we deployed RobEthiChor-Ros on real\nrobots and ran scenarios where a pair of robots negotiate upon resource\ncontention. Experimental results demonstrate the feasibility and effectiveness\nof the system in realizing ethics-based negotiation. RobEthiChor allowed robots\nto reach an agreement in more than 73\\% of the scenarios with an acceptable\nnegotiation time (0.67s on average). Experiments also demonstrate that the\nnegotiation approach implemented in RobEthiChor is scalable."}
{"id": "2507.22847", "categories": ["cs.AI", "cs.CL", "cs.CY"], "pdf": "https://arxiv.org/pdf/2507.22847", "abs": "https://arxiv.org/abs/2507.22847", "authors": ["Han Jiang", "Pengda Wang", "Xiaoyuan Yi", "Xing Xie", "Ziang Xiao"], "title": "The Incomplete Bridge: How AI Research (Mis)Engages with Psychology", "comment": null, "summary": "Social sciences have accumulated a rich body of theories and methodologies\nfor investigating the human mind and behaviors, while offering valuable\ninsights into the design and understanding of Artificial Intelligence (AI)\nsystems. Focusing on psychology as a prominent case, this study explores the\ninterdisciplinary synergy between AI and the field by analyzing 1,006\nLLM-related papers published in premier AI venues between 2023 and 2025, along\nwith the 2,544 psychology publications they cite. Through our analysis, we\nidentify key patterns of interdisciplinary integration, locate the psychology\ndomains most frequently referenced, and highlight areas that remain\nunderexplored. We further examine how psychology theories/frameworks are\noperationalized and interpreted, identify common types of misapplication, and\noffer guidance for more effective incorporation. Our work provides a\ncomprehensive map of interdisciplinary engagement between AI and psychology,\nthereby facilitating deeper collaboration and advancing AI systems."}
{"id": "2507.22674", "categories": ["cs.CR"], "pdf": "https://arxiv.org/pdf/2507.22674", "abs": "https://arxiv.org/abs/2507.22674", "authors": ["Ramprasad Sarkar"], "title": "Cryptanalysis of LC-MUME: A Lightweight Certificateless Multi-User Matchmaking Encryption for Mobile Devices", "comment": null, "summary": "Yang et al. proposed a lightweight certificateless multiuser matchmaking\nencryption (LC-MUME) scheme for mobile devices, published in IEEE Transactions\non Information Forensics and Security (TIFS) (DOI: 10.1109/TIFS.2023.3321961).\nTheir construction aims to reduce computational and communication overhead\nwithin a one-to-many certificateless cryptographic framework. The authors claim\nthat their scheme satisfies existential unforgeability under chosen-message\nattacks (EUF-CMA) in the random oracle model. However, our cryptanalytic study\ndemonstrates that the scheme fails to meet this critical security requirement.\nIn particular, we show that a Type-I adversary can successfully forge a valid\nciphertext without possessing the complete private key of the sender. Both\ntheoretical analysis and practical implementation confirm that this attack can\nbe mounted with minimal computational cost. To address these weaknesses, we\npropose a modification strategy to strengthen the security of matchmaking\nencryption schemes in mobile computing environments."}
{"id": "2507.22800", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.22800", "abs": "https://arxiv.org/abs/2507.22800", "authors": ["Rui Ren"], "title": "The Multi-Agent Fault Localization System Based on Monte Carlo Tree Search Approach", "comment": null, "summary": "In real-world scenarios, due to the highly decoupled and flexible nature of\nmicroservices, it poses greater challenges to system reliability. The more\nfrequent occurrence of incidents has created a demand for Root Cause\nAnalysis(RCA) methods that enable rapid identification and recovery of\nincidents. Large language model (LLM) provides a new path for quickly locating\nand recovering from incidents by leveraging their powerful generalization\nability combined with expert experience. Current LLM for RCA frameworks are\nbased on ideas like ReAct and Chain-of-Thought, but the hallucination of LLM\nand the propagation nature of anomalies often lead to incorrect localization\nresults. Moreover, the massive amount of anomalous information generated in\nlarge, complex systems presents a huge challenge for the context window length\nof LLMs. To address these challenges, we propose KnowledgeMind, an innovative\nLLM multi-agent system based on Monte Carlo Tree Search and a knowledge base\nreward mechanism for standardized service-by-service reasoning. Compared to\nState-Of-The-Art(SOTA) LLM for RCA methods, our service-by-service exploration\napproach significantly reduces the burden on the maximum context window length,\nrequiring only one-tenth of its size. Additionally, by incorporating a\nrule-based real-time reward mechanism, our method effectively mitigates\nhallucinations during the inference process. Compared to the SOTA LLM for RCA\nframework, our method achieves a 49.29% to 128.35% improvement in root cause\nlocalization accuracy."}
{"id": "2507.22876", "categories": ["cs.AI", "cs.LO"], "pdf": "https://arxiv.org/pdf/2507.22876", "abs": "https://arxiv.org/abs/2507.22876", "authors": ["Yiwen Sun", "Furong Ye", "Zhihan Chen", "Ke Wei", "Shaowei Cai"], "title": "Automatically discovering heuristics in a complex SAT solver with large language models", "comment": null, "summary": "Satisfiability problem (SAT) is a cornerstone of computational complexity\nwith broad industrial applications, and it remains challenging to optimize\nmodern SAT solvers in real-world settings due to their intricate architectures.\nWhile automatic configuration frameworks have been developed, they rely on\nmanually constrained search spaces and yield limited performance gains. This\nwork introduces a novel paradigm which effectively optimizes complex SAT\nsolvers via Large Language Models (LLMs), and a tool called AutoModSAT is\ndeveloped. Three fundamental challenges are addressed in order to achieve\nsuperior performance: (1) LLM-friendly solver: Systematic guidelines are\nproposed for developing a modularized solver to meet LLMs' compatibility,\nemphasizing code simplification, information share and bug reduction; (2)\nAutomatic prompt optimization: An unsupervised automatic prompt optimization\nmethod is introduced to advance the diversity of LLMs' output; (3) Efficient\nsearch strategy: We design a presearch strategy and an EA evolutionary\nalgorithm for the final efficient and effective discovery of heuristics.\nExtensive experiments across a wide range of datasets demonstrate that\nAutoModSAT achieves 50% performance improvement over the baseline solver and\nachieves 30% superiority against the state-of-the-art (SOTA) solvers. Moreover,\nAutoModSAT attains a 20% speedup on average compared to parameter-tuned\nalternatives of the SOTA solvers, showcasing the enhanced capability in\nhandling complex problem instances. This work bridges the gap between AI-driven\nheuristics discovery and mission-critical system optimization, and provides\nboth methodological advancements and empirically validated results for\nnext-generation complex solver development."}
{"id": "2507.22772", "categories": ["cs.CR", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2507.22772", "abs": "https://arxiv.org/abs/2507.22772", "authors": ["Ahmed Sabbah", "Radi Jarrar", "Samer Zein", "David Mohaisen"], "title": "Empirical Evaluation of Concept Drift in ML-Based Android Malware Detection", "comment": "18 pages, 12 tables, 14 figures, paper under review", "summary": "Despite outstanding results, machine learning-based Android malware detection\nmodels struggle with concept drift, where rapidly evolving malware\ncharacteristics degrade model effectiveness. This study examines the impact of\nconcept drift on Android malware detection, evaluating two datasets and nine\nmachine learning and deep learning algorithms, as well as Large Language Models\n(LLMs). Various feature types--static, dynamic, hybrid, semantic, and\nimage-based--were considered. The results showed that concept drift is\nwidespread and significantly affects model performance. Factors influencing the\ndrift include feature types, data environments, and detection methods.\nBalancing algorithms helped with class imbalance but did not fully address\nconcept drift, which primarily stems from the dynamic nature of the malware\nlandscape. No strong link was found between the type of algorithm used and\nconcept drift, the impact was relatively minor compared to other variables\nsince hyperparameters were not fine-tuned, and the default algorithm\nconfigurations were used. While LLMs using few-shot learning demonstrated\npromising detection performance, they did not fully mitigate concept drift,\nhighlighting the need for further investigation."}
{"id": "2507.22853", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2507.22853", "abs": "https://arxiv.org/abs/2507.22853", "authors": ["Haichuan Hu", "Xiaochen Xie", "Quanjun Zhang"], "title": "Repair-R1: Better Test Before Repair", "comment": null, "summary": "APR (Automated Program Repair) aims to automatically locate program defects,\ngenerate patches and validate the repairs. Existing techniques for APR are\noften combined with LLMs (Large Language Models), which leverages the\ncode-related knowledge of LLMs to improve repair effectiveness. Current\nLLM-based APR methods typically utilize test cases only during the inference\nstage, adopting an iterative approach that performs repair first and validates\nit through test execution afterward. This conventional paradigm neglects two\nimportant aspects: the potential contribution of test cases in the training\nphase, and the possibility of leveraging testing prior to repair. To address\nthis, we propose Repair-R1, which introduces test cases into the model's\ntraining phase and shifts test generation to precede repair. The model is\nrequired to first generate discriminative test cases that can distinguish\ndefective behaviors, and then perform repair based on these tests. This enables\nthe model to better locate defects and understand the underlying causes of\ndefects, thereby improving repair effectiveness. We implement Repair-R1 with\nthree different backbone models, using RL (reinforcement learning) to\nco-optimize test generation and bug repair. Experimental results on four widely\nadopted benchmarks demonstrate the superiority of Repair-R1. Specially,\ncompared to vanilla models, Repair-R1 improves repair success rate by 2.68\\% to\n48.29\\%, test generation success rate by 16.38\\% to 53.28\\%, and test coverage\nby 0.78\\% to 53.96\\%. We publish the code and weights at\nhttps://github.com/Tomsawyerhu/APR-RL and\nhttps://huggingface.co/tomhu/Qwen3-4B-RL-5000-step."}
{"id": "2507.22063", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2507.22063", "abs": "https://arxiv.org/abs/2507.22063", "authors": ["Wenjie Jacky Mo", "Qin Liu", "Xiaofei Wen", "Dongwon Jung", "Hadi Askari", "Wenxuan Zhou", "Zhe Zhao", "Muhao Chen"], "title": "RedCoder: Automated Multi-Turn Red Teaming for Code LLMs", "comment": null, "summary": "Large Language Models (LLMs) for code generation (i.e., Code LLMs) have\ndemonstrated impressive capabilities in AI-assisted software development and\ntesting. However, recent studies have shown that these models are prone to\ngenerating vulnerable or even malicious code under adversarial settings.\nExisting red-teaming approaches rely on extensive human effort, limiting their\nscalability and practicality, and generally overlook the interactive nature of\nreal-world AI-assisted programming, which often unfolds over multiple turns. To\nbridge these gaps, we present RedCoder, a red-teaming agent that engages victim\nmodels in multi-turn conversation to elicit vulnerable code. The pipeline to\nconstruct RedCoder begins with a multi-agent gaming process that simulates\nadversarial interactions, yielding a set of prototype conversations and an\narsenal of reusable attack strategies. We then fine-tune an LLM on these\nprototype conversations to serve as the backbone of RedCoder. Once deployed,\nRedCoder autonomously engages Code LLMs in multi-turn conversations,\ndynamically retrieving relevant strategies from the arsenal to steer the\ndialogue toward vulnerability-inducing outputs. Experiments across multiple\nCode LLMs show that our approach outperforms prior single-turn and multi-turn\nred-team methods in inducing vulnerabilities in code generation, offering a\nscalable and effective tool for evaluating the security boundaries of modern\ncode-generation systems."}
{"id": "2507.22065", "categories": ["cs.SE", "cs.AI", "cs.CR", "cs.PL"], "pdf": "https://arxiv.org/pdf/2507.22065", "abs": "https://arxiv.org/abs/2507.22065", "authors": ["Xiaotao Feng", "Xiaogang Zhu", "Kun Hu", "Jincheng Wang", "Yingjie Cao", "Guang Gong", "Jianfeng Pan"], "title": "Fuzzing: Randomness? Reasoning! Efficient Directed Fuzzing via Large Language Models", "comment": null, "summary": "Fuzzing is highly effective in detecting bugs due to the key contribution of\nrandomness. However, randomness significantly reduces the efficiency of\nfuzzing, causing it to cost days or weeks to expose bugs. Even though directed\nfuzzing reduces randomness by guiding fuzzing towards target buggy locations,\nthe dilemma of randomness still challenges directed fuzzers. Two critical\ncomponents, which are seeds and mutators, contain randomness and are closely\ntied to the conditions required for triggering bugs. Therefore, to address the\nchallenge of randomness, we propose to use large language models (LLMs) to\nremove the randomness in seeds and reduce the randomness in mutators. With\ntheir strong reasoning and code generation capabilities, LLMs can be used to\ngenerate reachable seeds that target pre-determined locations and to construct\nbug-specific mutators tailored for specific bugs. We propose RandLuzz, which\nintegrates LLMs and directed fuzzing, to improve the quality of seeds and\nmutators, resulting in efficient bug exposure. RandLuzz analyzes function call\nchain or functionality to guide LLMs in generating reachable seeds. To\nconstruct bug-specific mutators, RandLuzz uses LLMs to perform bug analysis,\nobtaining information such as bug causes and mutation suggestions, which\nfurther help generate code that performs bug-specific mutations. We evaluate\nRandLuzz by comparing it with four state-of-the-art directed fuzzers, AFLGo,\nBeacon, WindRanger, and SelectFuzz. With RandLuzz-generated seeds, the fuzzers\nachieve an average speedup ranging from 2.1$\\times$ to 4.8$\\times$ compared to\nusing widely-used initial seeds. Additionally, when evaluated on individual\nbugs, RandLuzz achieves up to a 2.7$\\times$ speedup compared to the\nsecond-fastest exposure. On 8 bugs, RandLuzz can even expose them within 60\nseconds."}
{"id": "2507.22871", "categories": ["cs.SE", "cs.DL", "D.2.13"], "pdf": "https://arxiv.org/pdf/2507.22871", "abs": "https://arxiv.org/abs/2507.22871", "authors": ["Domhnall Carlin", "Austen Rainer"], "title": "Tracking research software outputs in the UK", "comment": null, "summary": "Research software is crucial in the research process and the growth of Open\nScience underscores the importance of accessing research artifacts, like data\nand code, raising traceability challenges among outputs. While it is a clear\nprinciple that research code, along with other essential outputs, should be\nrecognised as artifacts of the research process, the how of this principle\nremains variable. This study examines where UK academic institutions store and\nregister software as a unique research output, searching the UKRI's Gateway to\nResearch (GtR) metadata for publicly funded research software in the UK. The\nquantity of software reported as research outcomes remains low in proportion to\nother categories. Artifact sharing appears low, with one-quarter of the\nreported software having no links and 45% having either a missing or erroneous\nURL. Of the valid URLs, we find the single largest category is Public\nCommercial Code Repository, with GitHub being the host of 18% of all publicly\nfunded research software listed. These observations are contrasted with past\nfindings from 2023 and finally, we discuss the lack of artifact sharing in UK\nresearch, with resulting implications for the maintenance and evolution of\nresearch software. Without dissemination, research software risks demotion to a\ntransient artifact, useful only to meet short term research demands but\nultimately lost to the broader enterprise of science."}
{"id": "2507.22064", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2507.22064", "abs": "https://arxiv.org/abs/2507.22064", "authors": ["Michael Cohoon", "Debbie Furman"], "title": "Machine Learning Experiences: A story of learning AI for use in enterprise software testing that can be used by anyone", "comment": null, "summary": "This paper details the machine learning (ML) journey of a group of people\nfocused on software testing. It tells the story of how this group progressed\nthrough a ML workflow (similar to the CRISP-DM process). This workflow consists\nof the following steps and can be used by anyone applying ML techniques to a\nproject: gather the data; clean the data; perform feature engineering on the\ndata; splitting the data into two sets, one for training and one for testing;\nchoosing a machine learning model; training the model; testing the model and\nevaluating the model performance. By following this workflow, anyone can\neffectively apply ML to any project that they are doing."}
{"id": "2507.22066", "categories": ["cs.SE", "cs.CR"], "pdf": "https://arxiv.org/pdf/2507.22066", "abs": "https://arxiv.org/abs/2507.22066", "authors": ["Dylan Manuel", "Paul Rad"], "title": "CodableLLM: Automating Decompiled and Source Code Mapping for LLM Dataset Generation", "comment": null, "summary": "The generation of large, high-quality datasets for code understanding and\ngeneration remains a significant challenge, particularly when aligning\ndecompiled binaries with their original source code. To address this, we\npresent CodableLLM, a Python framework designed to automate the creation and\ncuration of datasets by mapping decompiled functions to their corresponding\nsource functions. This process enhances the alignment between decompiled and\nsource code representations, facilitating the development of large language\nmodels (LLMs) capable of understanding and generating code across multiple\nabstraction levels. CodableLLM supports multiple programming languages and\nintegrates with existing decompilers and parsers to streamline dataset\ngeneration. This paper presents the design and implementation of CodableLLM,\nevaluates its performance in dataset creation, and compares it to existing\ntools in the field. The results demonstrate that CodableLLM offers a robust and\nefficient solution for generating datasets tailored for code-focused LLMS."}
{"id": "2507.22371", "categories": ["cs.CR", "cs.AI", "cs.SE"], "pdf": "https://arxiv.org/pdf/2507.22371", "abs": "https://arxiv.org/abs/2507.22371", "authors": ["Lei Yu", "Shiqi Cheng", "Zhirong Huang", "Jingyuan Zhang", "Chenjie Shen", "Junyi Lu", "Li Yang", "Fengjun Zhang", "Jiajia Ma"], "title": "SAEL: Leveraging Large Language Models with Adaptive Mixture-of-Experts for Smart Contract Vulnerability Detection", "comment": "Accepted to ICSME 2025", "summary": "With the increasing security issues in blockchain, smart contract\nvulnerability detection has become a research focus. Existing vulnerability\ndetection methods have their limitations: 1) Static analysis methods struggle\nwith complex scenarios. 2) Methods based on specialized pre-trained models\nperform well on specific datasets but have limited generalization capabilities.\nIn contrast, general-purpose Large Language Models (LLMs) demonstrate\nimpressive ability in adapting to new vulnerability patterns. However, they\noften underperform on specific vulnerability types compared to methods based on\nspecialized pre-trained models. We also observe that explanations generated by\ngeneral-purpose LLMs can provide fine-grained code understanding information,\ncontributing to improved detection performance.\n  Inspired by these observations, we propose SAEL, an LLM-based framework for\nsmart contract vulnerability detection. We first design targeted prompts to\nguide LLMs in identifying vulnerabilities and generating explanations, which\nserve as prediction features. Next, we apply prompt-tuning on CodeT5 and T5 to\nprocess contract code and explanations, enhancing task-specific performance. To\ncombine the strengths of each approach, we introduce an Adaptive\nMixture-of-Experts architecture. This dynamically adjusts feature weights via a\nGating Network, which selects relevant features using TopK filtering and\nSoftmax normalization, and incorporates a Multi-Head Self-Attention mechanism\nto enhance cross-feature relationships. This design enables effective\nintegration of LLM predictions, explanation features, and code features through\ngradient optimization. The loss function jointly considers both independent\nfeature performance and overall weighted predictions. Experiments show that\nSAEL outperforms existing methods across various vulnerabilities."}
{"id": "2507.22065", "categories": ["cs.SE", "cs.AI", "cs.CR", "cs.PL"], "pdf": "https://arxiv.org/pdf/2507.22065", "abs": "https://arxiv.org/abs/2507.22065", "authors": ["Xiaotao Feng", "Xiaogang Zhu", "Kun Hu", "Jincheng Wang", "Yingjie Cao", "Guang Gong", "Jianfeng Pan"], "title": "Fuzzing: Randomness? Reasoning! Efficient Directed Fuzzing via Large Language Models", "comment": null, "summary": "Fuzzing is highly effective in detecting bugs due to the key contribution of\nrandomness. However, randomness significantly reduces the efficiency of\nfuzzing, causing it to cost days or weeks to expose bugs. Even though directed\nfuzzing reduces randomness by guiding fuzzing towards target buggy locations,\nthe dilemma of randomness still challenges directed fuzzers. Two critical\ncomponents, which are seeds and mutators, contain randomness and are closely\ntied to the conditions required for triggering bugs. Therefore, to address the\nchallenge of randomness, we propose to use large language models (LLMs) to\nremove the randomness in seeds and reduce the randomness in mutators. With\ntheir strong reasoning and code generation capabilities, LLMs can be used to\ngenerate reachable seeds that target pre-determined locations and to construct\nbug-specific mutators tailored for specific bugs. We propose RandLuzz, which\nintegrates LLMs and directed fuzzing, to improve the quality of seeds and\nmutators, resulting in efficient bug exposure. RandLuzz analyzes function call\nchain or functionality to guide LLMs in generating reachable seeds. To\nconstruct bug-specific mutators, RandLuzz uses LLMs to perform bug analysis,\nobtaining information such as bug causes and mutation suggestions, which\nfurther help generate code that performs bug-specific mutations. We evaluate\nRandLuzz by comparing it with four state-of-the-art directed fuzzers, AFLGo,\nBeacon, WindRanger, and SelectFuzz. With RandLuzz-generated seeds, the fuzzers\nachieve an average speedup ranging from 2.1$\\times$ to 4.8$\\times$ compared to\nusing widely-used initial seeds. Additionally, when evaluated on individual\nbugs, RandLuzz achieves up to a 2.7$\\times$ speedup compared to the\nsecond-fastest exposure. On 8 bugs, RandLuzz can even expose them within 60\nseconds."}
{"id": "2507.22080", "categories": ["cs.SE", "cs.AI", "cs.CL"], "pdf": "https://arxiv.org/pdf/2507.22080", "abs": "https://arxiv.org/abs/2507.22080", "authors": ["Qiushi Sun", "Jinyang Gong", "Lei Li", "Qipeng Guo", "Fei Yuan"], "title": "CodeEvo: Interaction-Driven Synthesis of Code-centric Data through Hybrid and Iterative Feedback", "comment": "Work in progress", "summary": "Acquiring high-quality instruction-code pairs is essential for training Large\nLanguage Models (LLMs) for code generation. Manually curated data is expensive\nand inherently limited in scale, motivating the development of code-centric\nsynthesis methods. Yet, current approaches either focus on augmenting existing\ncode or rely on predefined heuristics, both lacking rigorous data validation,\nwhich results in synthetic data that is ungrounded, repetitive, or overly\nsimplistic. Inspired by collaborative programming practices, we propose\nCodeEvo, a framework that synthesizes code data through iterative interactions\nbetween two LLM agents: a Coder, which generates candidate code and test cases\nbased on given instructions, and a Reviewer, which guides the synthesis process\nby producing new instructions and feedback. We further introduce a hybrid\nfeedback mechanism that combines compiler determinism with the generative\nflexibility of agents, enabling automatic quality control throughout synthesis.\nExtensive experiments demonstrate that models fine-tuned on CodeEvo data\nsignificantly outperform established baselines across code generation\nbenchmarks with various difficulties. In-depth analyses further provide\ninsights from multiple perspectives into effective code-centric data synthesis."}
{"id": "2507.22086", "categories": ["cs.SE", "cs.AI", "cs.PL"], "pdf": "https://arxiv.org/pdf/2507.22086", "abs": "https://arxiv.org/abs/2507.22086", "authors": ["Honghua Dong", "Jiacheng Yang", "Xun Deng", "Yuhe Jiang", "Gennady Pekhimenko", "Fan Long", "Xujie Si"], "title": "TypyBench: Evaluating LLM Type Inference for Untyped Python Repositories", "comment": null, "summary": "Type inference for dynamic languages like Python is a persistent challenge in\nsoftware engineering. While large language models (LLMs) have shown promise in\ncode understanding, their type inference capabilities remain underexplored. We\nintroduce TypyBench, a benchmark designed to evaluate LLMs' type inference\nacross entire Python repositories. TypyBench features two novel metrics:\nTypeSim, which captures nuanced semantic relationships between predicted and\nground truth types, and TypeCheck, which assesses type consistency across\ncodebases. Our evaluation of various LLMs on a curated dataset of 50\nhigh-quality Python repositories reveals that, although LLMs achieve decent\nTypeSim scores, they struggle with complex nested types and exhibit significant\ntype consistency errors. These findings suggest that future research should\nshift focus from improving type similarity to addressing repository-level\nconsistency. TypyBench provides a foundation for this new direction, offering\ninsights into model performance across different type complexities and usage\ncontexts. Our code and data are available at\nhttps://github.com/typybench/typybench."}
{"id": "2507.22160", "categories": ["cs.CR", "cs.AI", "cs.CL"], "pdf": "https://arxiv.org/pdf/2507.22160", "abs": "https://arxiv.org/abs/2507.22160", "authors": ["Yassine Rachidy", "Jihad Rbaiti", "Youssef Hmamouche", "Faissal Sehbaoui", "Amal El Fallah Seghrouchni"], "title": "Strategic Deflection: Defending LLMs from Logit Manipulation", "comment": "20 pages", "summary": "With the growing adoption of Large Language Models (LLMs) in critical areas,\nensuring their security against jailbreaking attacks is paramount. While\ntraditional defenses primarily rely on refusing malicious prompts, recent\nlogit-level attacks have demonstrated the ability to bypass these safeguards by\ndirectly manipulating the token-selection process during generation. We\nintroduce Strategic Deflection (SDeflection), a defense that redefines the\nLLM's response to such advanced attacks. Instead of outright refusal, the model\nproduces an answer that is semantically adjacent to the user's request yet\nstrips away the harmful intent, thereby neutralizing the attacker's harmful\nintent. Our experiments demonstrate that SDeflection significantly lowers\nAttack Success Rate (ASR) while maintaining model performance on benign\nqueries. This work presents a critical shift in defensive strategies, moving\nfrom simple refusal to strategic content redirection to neutralize advanced\nthreats."}
{"id": "2507.22171", "categories": ["cs.CR", "cs.AI"], "pdf": "https://arxiv.org/pdf/2507.22171", "abs": "https://arxiv.org/abs/2507.22171", "authors": ["Zheng Zhang", "Peilin Zhao", "Deheng Ye", "Hao Wang"], "title": "Enhancing Jailbreak Attacks on LLMs via Persona Prompts", "comment": null, "summary": "Jailbreak attacks aim to exploit large language models (LLMs) by inducing\nthem to generate harmful content, thereby revealing their vulnerabilities.\nUnderstanding and addressing these attacks is crucial for advancing the field\nof LLM safety. Previous jailbreak approaches have mainly focused on direct\nmanipulations of harmful intent, with limited attention to the impact of\npersona prompts. In this study, we systematically explore the efficacy of\npersona prompts in compromising LLM defenses. We propose a genetic\nalgorithm-based method that automatically crafts persona prompts to bypass\nLLM's safety mechanisms. Our experiments reveal that: (1) our evolved persona\nprompts reduce refusal rates by 50-70% across multiple LLMs, and (2) these\nprompts demonstrate synergistic effects when combined with existing attack\nmethods, increasing success rates by 10-20%. Our code and data are available at\nhttps://github.com/CjangCjengh/Generic_Persona."}
{"id": "2507.22239", "categories": ["cs.CR", "cs.AI", "cs.SY", "eess.SY"], "pdf": "https://arxiv.org/pdf/2507.22239", "abs": "https://arxiv.org/abs/2507.22239", "authors": ["Muhammad Sharshar", "Ahmad Mohammad Saber", "Davor Svetinovic", "Amr M. Youssef", "Deepa Kundur", "Ehab F. El-Saadany"], "title": "Large Language Model-Based Framework for Explainable Cyberattack Detection in Automatic Generation Control Systems", "comment": "Accepted Publication", "summary": "The increasing digitization of smart grids has improved operational\nefficiency but also introduced new cybersecurity vulnerabilities, such as False\nData Injection Attacks (FDIAs) targeting Automatic Generation Control (AGC)\nsystems. While machine learning (ML) and deep learning (DL) models have shown\npromise in detecting such attacks, their opaque decision-making limits operator\ntrust and real-world applicability. This paper proposes a hybrid framework that\nintegrates lightweight ML-based attack detection with natural language\nexplanations generated by Large Language Models (LLMs). Classifiers such as\nLightGBM achieve up to 95.13% attack detection accuracy with only 0.004 s\ninference latency. Upon detecting a cyberattack, the system invokes LLMs,\nincluding GPT-3.5 Turbo, GPT-4 Turbo, and GPT-4o mini, to generate\nhuman-readable explanation of the event. Evaluated on 100 test samples, GPT-4o\nmini with 20-shot prompting achieved 93% accuracy in identifying the attack\ntarget, a mean absolute error of 0.075 pu in estimating attack magnitude, and\n2.19 seconds mean absolute error (MAE) in estimating attack onset. These\nresults demonstrate that the proposed framework effectively balances real-time\ndetection with interpretable, high-fidelity explanations, addressing a critical\nneed for actionable AI in smart grid cybersecurity."}
{"id": "2507.22324", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2507.22324", "abs": "https://arxiv.org/abs/2507.22324", "authors": ["Cameron S. Movassaghi", "Amanda Momenzadeh", "Jesse G. Meyer"], "title": "From Articles to Code: On-Demand Generation of Core Algorithms from Scientific Publications", "comment": null, "summary": "Maintaining software packages imposes significant costs due to dependency\nmanagement, bug fixes, and versioning. We show that rich method descriptions in\nscientific publications can serve as standalone specifications for modern large\nlanguage models (LLMs), enabling on-demand code generation that could supplant\nhuman-maintained libraries. We benchmark state-of-the-art models\n(GPT-o4-mini-high, Gemini Pro 2.5, Claude Sonnet 4) by tasking them with\nimplementing a diverse set of core algorithms drawn from original publications.\nOur results demonstrate that current LLMs can reliably reproduce package\nfunctionality with performance indistinguishable from conventional libraries.\nThese findings foreshadow a paradigm shift toward flexible, on-demand code\ngeneration and away from static, human-maintained packages, which will result\nin reduced maintenance overhead by leveraging published articles as sufficient\ncontext for the automated implementation of analytical workflows."}
{"id": "2507.22371", "categories": ["cs.CR", "cs.AI", "cs.SE"], "pdf": "https://arxiv.org/pdf/2507.22371", "abs": "https://arxiv.org/abs/2507.22371", "authors": ["Lei Yu", "Shiqi Cheng", "Zhirong Huang", "Jingyuan Zhang", "Chenjie Shen", "Junyi Lu", "Li Yang", "Fengjun Zhang", "Jiajia Ma"], "title": "SAEL: Leveraging Large Language Models with Adaptive Mixture-of-Experts for Smart Contract Vulnerability Detection", "comment": "Accepted to ICSME 2025", "summary": "With the increasing security issues in blockchain, smart contract\nvulnerability detection has become a research focus. Existing vulnerability\ndetection methods have their limitations: 1) Static analysis methods struggle\nwith complex scenarios. 2) Methods based on specialized pre-trained models\nperform well on specific datasets but have limited generalization capabilities.\nIn contrast, general-purpose Large Language Models (LLMs) demonstrate\nimpressive ability in adapting to new vulnerability patterns. However, they\noften underperform on specific vulnerability types compared to methods based on\nspecialized pre-trained models. We also observe that explanations generated by\ngeneral-purpose LLMs can provide fine-grained code understanding information,\ncontributing to improved detection performance.\n  Inspired by these observations, we propose SAEL, an LLM-based framework for\nsmart contract vulnerability detection. We first design targeted prompts to\nguide LLMs in identifying vulnerabilities and generating explanations, which\nserve as prediction features. Next, we apply prompt-tuning on CodeT5 and T5 to\nprocess contract code and explanations, enhancing task-specific performance. To\ncombine the strengths of each approach, we introduce an Adaptive\nMixture-of-Experts architecture. This dynamically adjusts feature weights via a\nGating Network, which selects relevant features using TopK filtering and\nSoftmax normalization, and incorporates a Multi-Head Self-Attention mechanism\nto enhance cross-feature relationships. This design enables effective\nintegration of LLM predictions, explanation features, and code features through\ngradient optimization. The loss function jointly considers both independent\nfeature performance and overall weighted predictions. Experiments show that\nSAEL outperforms existing methods across various vulnerabilities."}
{"id": "2507.22580", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2507.22580", "abs": "https://arxiv.org/abs/2507.22580", "authors": ["Marcos Fuster-Pena", "David de-Fitero-Dominguez", "Antonio Garcia-Cabot", "Eva Garcia-Lopez"], "title": "RePaCA: Leveraging Reasoning Large Language Models for Static Automated Patch Correctness Assessment", "comment": null, "summary": "Automated Program Repair (APR) seeks to automatically correct software bugs\nwithout requiring human intervention. However, existing tools tend to generate\npatches that satisfy test cases without fixing the underlying bug, those are\nknown as overfitting patches. To address this issue, Automated Patch\nCorrectness Assessment (APCA) attempts to identify overfitting patches\ngenerated by APR tools. It can be solved as a static approach, meaning that no\nadditional information is needed beyond the original and fixed code snippets.\nCurrent static techniques often struggle with reliability, flexibility and\ntransparency. To address these issues, we introduce RePaCA, a novel static APCA\ntechnique that leverages Large Language Models (LLMs) specialized in thinking\ntasks. Our model is prompted with both buggy and fixed code snippets and guided\nto generate a Chain of Thought that analyses code differences, reasons about\nhow the patch addresses the root cause, and ultimately provides a binary\nclassification: correct or overfitting. To enhance these reasoning capabilities\nfor the APCA task specifically, the LLM is finetuned using Reinforcement\nLearning with the Group Relative Policy Optimization algorithm. When evaluated\non a standard Defects4J-derived test, our approach achieves state-of-the-art\nperformance, with 83.1% accuracy and an 84.8% F1-score. Furthermore, our model\ndemonstrates superior generalization capabilities when trained on different\ndatasets, outperforming the leading technique. This reasoning capability also\nprovides enhanced explainability for the patch assessment. These findings\nunderscore the considerable promise of finetuned, reasoning LLMs to advance\nstatic APCA by enhancing accuracy, generalization, and explainability."}
{"id": "2507.22610", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2507.22610", "abs": "https://arxiv.org/abs/2507.22610", "authors": ["Ali Asgari", "Milan de Koning", "Pouria Derakhshanfar", "Annibale Panichella"], "title": "Metamorphic Testing of Deep Code Models: A Systematic Literature Review", "comment": null, "summary": "Large language models and deep learning models designed for code intelligence\nhave revolutionized the software engineering field due to their ability to\nperform various code-related tasks. These models can process source code and\nsoftware artifacts with high accuracy in tasks such as code completion, defect\ndetection, and code summarization; therefore, they can potentially become an\nintegral part of modern software engineering practices. Despite these\ncapabilities, robustness remains a critical quality attribute for deep-code\nmodels as they may produce different results under varied and adversarial\nconditions (e.g., variable renaming). Metamorphic testing has become a widely\nused approach to evaluate models' robustness by applying semantic-preserving\ntransformations to input programs and analyzing the stability of model outputs.\nWhile prior research has explored testing deep learning models, this systematic\nliterature review focuses specifically on metamorphic testing for deep code\nmodels. By studying 45 primary papers, we analyze the transformations,\ntechniques, and evaluation methods used to assess robustness. Our review\nsummarizes the current landscape, identifying frequently evaluated models,\nprogramming tasks, datasets, target languages, and evaluation metrics, and\nhighlights key challenges and future directions for advancing the field."}
{"id": "2507.22659", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2507.22659", "abs": "https://arxiv.org/abs/2507.22659", "authors": ["Sabrina Kaniewski", "Fabian Schmidt", "Markus Enzweiler", "Michael Menth", "Tobias Heer"], "title": "A Systematic Literature Review on Detecting Software Vulnerabilities with Large Language Models", "comment": "36 pages + 17 pages references, 6 tables, 10 figures", "summary": "The increasing adoption of Large Language Models (LLMs) in software\nengineering has sparked interest in their use for software vulnerability\ndetection. However, the rapid development of this field has resulted in a\nfragmented research landscape, with diverse studies that are difficult to\ncompare due to differences in, e.g., system designs and dataset usage. This\nfragmentation makes it difficult to obtain a clear overview of the\nstate-of-the-art or compare and categorize studies meaningfully. In this work,\nwe present a comprehensive systematic literature review (SLR) of LLM-based\nsoftware vulnerability detection. We analyze 227 studies published between\nJanuary 2020 and June 2025, categorizing them by task formulation, input\nrepresentation, system architecture, and adaptation techniques. Further, we\nanalyze the datasets used, including their characteristics, vulnerability\ncoverage, and diversity. We present a fine-grained taxonomy of vulnerability\ndetection approaches, identify key limitations, and outline actionable future\nresearch opportunities. By providing a structured overview of the field, this\nreview improves transparency and serves as a practical guide for researchers\nand practitioners aiming to conduct more comparable and reproducible research.\nWe publicly release all artifacts and maintain a living repository of LLM-based\nsoftware vulnerability detection studies."}
{"id": "2507.22664", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2507.22664", "abs": "https://arxiv.org/abs/2507.22664", "authors": ["Mashal Afzal Memon", "Gianluca Filippone", "Gian Luca Scoccia", "Marco Autili", "Paola Inverardi"], "title": "RobEthiChor: Automated Context-aware Ethics-based Negotiation for Autonomous Robots", "comment": null, "summary": "The presence of autonomous systems is growing at a fast pace and it is\nimpacting many aspects of our lives. Designed to learn and act independently,\nthese systems operate and perform decision-making without human intervention.\nHowever, they lack the ability to incorporate users' ethical preferences, which\nare unique for each individual in society and are required to personalize the\ndecision-making processes. This reduces user trust and prevents autonomous\nsystems from behaving according to the moral beliefs of their end-users. When\nmultiple systems interact with differing ethical preferences, they must\nnegotiate to reach an agreement that satisfies the ethical beliefs of all the\nparties involved and adjust their behavior consequently. To address this\nchallenge, this paper proposes RobEthiChor, an approach that enables autonomous\nsystems to incorporate user ethical preferences and contextual factors into\ntheir decision-making through ethics-based negotiation. RobEthiChor features a\ndomain-agnostic reference architecture for designing autonomous systems capable\nof ethic-based negotiating. The paper also presents RobEthiChor-Ros, an\nimplementation of RobEthiChor within the Robot Operating System (ROS), which\ncan be deployed on robots to provide them with ethics-based negotiation\ncapabilities. To evaluate our approach, we deployed RobEthiChor-Ros on real\nrobots and ran scenarios where a pair of robots negotiate upon resource\ncontention. Experimental results demonstrate the feasibility and effectiveness\nof the system in realizing ethics-based negotiation. RobEthiChor allowed robots\nto reach an agreement in more than 73\\% of the scenarios with an acceptable\nnegotiation time (0.67s on average). Experiments also demonstrate that the\nnegotiation approach implemented in RobEthiChor is scalable."}
{"id": "2507.22772", "categories": ["cs.CR", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2507.22772", "abs": "https://arxiv.org/abs/2507.22772", "authors": ["Ahmed Sabbah", "Radi Jarrar", "Samer Zein", "David Mohaisen"], "title": "Empirical Evaluation of Concept Drift in ML-Based Android Malware Detection", "comment": "18 pages, 12 tables, 14 figures, paper under review", "summary": "Despite outstanding results, machine learning-based Android malware detection\nmodels struggle with concept drift, where rapidly evolving malware\ncharacteristics degrade model effectiveness. This study examines the impact of\nconcept drift on Android malware detection, evaluating two datasets and nine\nmachine learning and deep learning algorithms, as well as Large Language Models\n(LLMs). Various feature types--static, dynamic, hybrid, semantic, and\nimage-based--were considered. The results showed that concept drift is\nwidespread and significantly affects model performance. Factors influencing the\ndrift include feature types, data environments, and detection methods.\nBalancing algorithms helped with class imbalance but did not fully address\nconcept drift, which primarily stems from the dynamic nature of the malware\nlandscape. No strong link was found between the type of algorithm used and\nconcept drift, the impact was relatively minor compared to other variables\nsince hyperparameters were not fine-tuned, and the default algorithm\nconfigurations were used. While LLMs using few-shot learning demonstrated\npromising detection performance, they did not fully mitigate concept drift,\nhighlighting the need for further investigation."}
{"id": "2507.22853", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2507.22853", "abs": "https://arxiv.org/abs/2507.22853", "authors": ["Haichuan Hu", "Xiaochen Xie", "Quanjun Zhang"], "title": "Repair-R1: Better Test Before Repair", "comment": null, "summary": "APR (Automated Program Repair) aims to automatically locate program defects,\ngenerate patches and validate the repairs. Existing techniques for APR are\noften combined with LLMs (Large Language Models), which leverages the\ncode-related knowledge of LLMs to improve repair effectiveness. Current\nLLM-based APR methods typically utilize test cases only during the inference\nstage, adopting an iterative approach that performs repair first and validates\nit through test execution afterward. This conventional paradigm neglects two\nimportant aspects: the potential contribution of test cases in the training\nphase, and the possibility of leveraging testing prior to repair. To address\nthis, we propose Repair-R1, which introduces test cases into the model's\ntraining phase and shifts test generation to precede repair. The model is\nrequired to first generate discriminative test cases that can distinguish\ndefective behaviors, and then perform repair based on these tests. This enables\nthe model to better locate defects and understand the underlying causes of\ndefects, thereby improving repair effectiveness. We implement Repair-R1 with\nthree different backbone models, using RL (reinforcement learning) to\nco-optimize test generation and bug repair. Experimental results on four widely\nadopted benchmarks demonstrate the superiority of Repair-R1. Specially,\ncompared to vanilla models, Repair-R1 improves repair success rate by 2.68\\% to\n48.29\\%, test generation success rate by 16.38\\% to 53.28\\%, and test coverage\nby 0.78\\% to 53.96\\%. We publish the code and weights at\nhttps://github.com/Tomsawyerhu/APR-RL and\nhttps://huggingface.co/tomhu/Qwen3-4B-RL-5000-step."}
